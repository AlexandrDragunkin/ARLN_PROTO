//-- Макропрограмма рисования объектов вдоль прямой
//-- Входные параметры:
//-- x1,y1,z1 - координаты начала профиля, по которому расставлять комплектующие
//-- x2,y2,z2 - координаты конца профиля
//-- IDPrice - ID комплектующего из прайса
//-- Name - название типа комплектующего из таблицы Types_Komp базы DoorSys.mdb
//-- Shift - величина начального и конечного сдвига объекта по профилю
//-- Coeff - зарезервировано
//-- MacroExtra - имя макропрограммы дополнительных преобразований
//-- программа устанавливает объект вдоль профиля,
//-- задавая начальное и конечное смещение, равное Shift

ullout=getvarinst(2,"Doors64",Doors64,"Doors64.zmc|");

global ProtoPath g_UserVar g_InstOpt g_symx g_symy  g_holder g_usercomp g_IDKomp g_Shift g_Coeff g_UIDKomp;
global
PrfP_1   // Подрез начальной точки
PrfP_2   // Подрез конечной точки
PrfSd_X  // Сдвиг по Х ЛСК
PrfSd_Y  // Сдвиг по У ЛСК
PrfAngle // Угол поворота вокруг оси (град)
PrfAng_1 // Угол подрезки 1 стороны
PrfAng_2 // Угол подрезки 2 стороны
;
// сохраняем
oPrfP_1=PrfP_1   // Подрез начальной точки
oPrfP_2=PrfP_2   // Подрез конечной точки
oPrfSd_X=PrfSd_X  // Сдвиг по Х ЛСК
oPrfSd_Y=PrfSd_Y  // Сдвиг по У ЛСК
oPrfAngle=PrfAngle // Угол поворота вокруг оси (град)
oPrfAng_1=PrfAng_1 // Угол подрезки 1 стороны
oPrfAng_2=PrfAng_2 // Угол подрезки 2 стороны
//=============
nulout=GetSnap();
global g_ExName g_ExVal g_ExInf gDopKompl; // массивы дополнительных параметров  системы
defarr aUnitC[20] xm[6];
defarr trans[16], in[3], out[3]; // Задаем массивы
NULLOUT=Ohcunit(trans);          // Задаем единичную матрицу преобразований

getpar x1,y1,z1 x2,y2,z2 IDPrice,Name,Shift,Coeff,MacroExtra;

//===================================
// Мы знаем ID системы, сечения профиля, группы комплектующего
// в соответствии с этими данными требуется найти все необходимые параметры для установки
// заданного комплектующего у которого может быть куча дополнительных параметров которые надо учесть и передать
//===================================
//-- Умолчания на направления ос0и OY
//xp3=x1;
//yp3=(y1+y2)/2+10;
//zp3=z1;
//putmsg(",.,.,.,.,.IDPrice="+str(IDPrice),1);
//#OBJUCS box 0 0 0 1 1 1 ;
//setucs x1,y1,z1 x2,y2,z2 xp3,yp3,zp3;
//if isvardef("g_holder")==16 { setucs lcs g_holder ; }
//-- Находим количество элементов
Shift=iif(g_Shift==0,Shift,g_Shift);
Coeff=iif(g_Coeff==0,Coeff,g_Coeff);
dx=x1-x2;
dy=y1-y2;
dz=z1-z2;
lenght=sqrt(dx*dx+dy*dy+dz*dz);
dlen=lenght-(gDopKompl[1]+2*shift);
//putmsg("shift = "+str(shift),1);
macro ProtoPath+"SetEnam.mac" Name ;
parName="MirrX";
gosub SetExParam;
MrX=iif(parVal!=0,iif(parVal<0,0,parVal),g_symX);
parName="MirrY";
gosub SetExParam;
MrY=iif(parVal!=0,iif(parVal<0,0,parVal),g_symY);
parName="PrcX";
gosub SetExParam;
SdvX=parVal*iif(g_symy==1,(-1),1)
parName="PrcY";
gosub SetExParam;
SdvY=parVal*iif(g_symx==1,(-1),1)
//- Параметр ifUnitCode строка со списком допустимых значений атрибута UnitCode  разделенных запятой
parName="ifUnitCode";
gosub SetExParam;
vUnitC=parVal;
//- Ситуация обязательной установки. Нужен признак ставить не ставить возможны варианты InstallOption
// 0-всегда 1-никогда 2-вариант пользователя
//- В ряде случаев надо выбирать из всех возвожных вариантов какой то один из всех предложенных в IfUnitCode
//- так при устанвке замка  есть три варианта (к стати для ручек таже песня)
//" |- замок справа-|"
//" |- замок слева-|"
//" |- 2 замка -|"
//- вариант может определять система или пользователь
//- изначально мы можем поставить замок на обе стороны дверки  vUnitC=6302,6304  если vUnitC=6302-слева или vUnitC=6304-справа
//- заметим, что это условие касается характеристики положения профиля в створке и не касается его геометрических характеристик
//- Наличие параметра InstallOption говорит о неоднозначности установки комплектующего если его нет то ставим везде где можем vUnitC=6302,6304
//- в противном случае необходимо создать запись для редактирования через скрейч установки комплектующего g_UserVar
//- смотрим в скрейче наличие записи InstallOption
parName="InstallOption";
gosub SetExParam;
g_InstOpt=parVal;
//g_IDKomp=0;
macro Protopath+Doors64+"ScrKomplGetSub.mac"  ;
parName="CurrNot";
gosub SetExParam;
CurrNot=parVal;
g_UIDKomp=iif((g_UIDKomp==-1)&&(CurrNot==1),0,g_UIDKomp);
//putmsg(",.,.,.,.,.g_InstOpt="+str(g_InstOpt),1);
//putmsg(",.,.,.,.,.g_UserVar="+str(g_UserVar),1);
//======================================================
if g_InstOpt==1
{
   goto end;
}
if g_InstOpt==2
{
   if isvardef("g_UserVar")==0
   {
      goto end;
   }
   
}
vUnitC=iif(g_UserVar=="",vUnitC,g_UserVar);
//======================================================
UnitC=Getattr(g_holder,"UnitCode","*");
vUnitC=str(vUnitC);
// putmsg("vUnitC="+vUnitC,1);
// putmsg("UnitC="+UnitC,1);
// putmsg("IDPrice="+str(IDPrice),1);
if len(vUnitC)>1
{
   Nulout=SplitByDelim(vUnitC,",",aUnitC);
   fPos=findinarray(aUnitC,val(UnitC));
}
else
{
   fPos=1;
}
if fpos==0
{
   goto end;
}
NULLOUT=Otdrot(trans,3,PrfAngle);     // Заносим в эту матрицу поворот относительно оси Z на
out[1]=SdvX*trans[1]+SdvY*trans[2]+0*trans[3]+trans[4];   // Вычисляем координаты
out[2]=SdvX*trans[5]+SdvY*trans[6]+0*trans[7]+trans[8];
out[3]=SdvX*trans[9]+SdvY*trans[10]+0*trans[11]+trans[12];
macro ProtoPath+"SetProfC.mac" IDPrice Shift Shift+iif(gDopKompl[1]!=0,dlen,0) PrfSd_X+out[1] PrfSd_Y+out[2] PrfAngle 0 0 0;   //*iif(g_symx==1,1,-1)

t_symx=g_symx;  //- Зеркальное отображение относительно оси X ЛСК
t_symy=g_symx;  //- Зеркальное отображение относительно оси Y ЛСК
macro ProtoPath+"SetProfS.mac" MrX MrY done ; // отражение по осям
Macro ProtoPath+Doors64+"MakeProf.mac" x1,y1,z1 x2,y2,z2 done ; //x1 -10000 z1; //0,0,0 lenght,0,0;
macro ProtoPath+"SetProfS.mac" t_symX t_symY done ; // отражение по осям
NULLOUT=Ohcunit(trans);
objident last 1 obj;

if (len(MacroExtra)!=0)
{
  macro ProtoPath+MacroExtra obj;
}
end:
// восстанавливаем
PrfP_1=oPrfP_1   // Подрез начальной точки
PrfP_2=oPrfP_2   // Подрез конечной точки
PrfSd_X=oPrfSd_X  // Сдвиг по Х ЛСК
PrfSd_Y=oPrfSd_Y  // Сдвиг по У ЛСК
PrfAngle=oPrfAngle // Угол поворота вокруг оси (град)
PrfAng_1=oPrfAng_1 // Угол подрезки 1 стороны
PrfAng_2=oPrfAng_2 // Угол подрезки 2 стороны
//=============
end1:
macro Protopath+Doors64+"ScrKomplAddSub.mac"  ;
nulout=ReSnap();
exit;
//========================================================
SetExParam:
        pos=FindInArray(g_ExName,parName);
		// putmsg("parName="+parName,1);
		// putmsg("pos="+str(pos),1);
        if pos>0
        {
                parVal=g_ExVal[pos];

        }
        else
        {
                parVal=0;
        }
		//putmsg("parVal="+str(parVal),1);
return;
