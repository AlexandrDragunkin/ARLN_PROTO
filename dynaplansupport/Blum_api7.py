# -*- coding: utf-8 -*-
import DynaplanSupport as mDy
#gExportPath = 'c:\Users\USER\Documents\Blum\Dynaplan\Export\\' # путь к папке для экспорта из Dynaplan
#
# Generated  by generateDS.py.
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = list(range(3))
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
            return input_data
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        def DrawTT(self): # for K3Mebel add
            pass
        def GroupChildObjectK3(self):  # for K3Mebel add
            pass


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'cp1251'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, str) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, str) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    if attr_name == 'PositionX':
        pass
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class Korpus(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Header=None, Parameterliste=None, Korpusdaten=None, Oberboden=None, Unterboden=None, LinkeSeitenwand=None, RechteSeitenwand=None, KorpusRueckwand=None, Platten=None, KorpusAnbindung=None, Tuer=None, Doppeltuer=None, Blindfront=None, Aussenschubkasten=None, Innenschubkasten=None, Traverse=None, Klappensystem=None, InnenFach=None, OffenesFach=None, Vorratsauszug=None, SERVODRIVE=None):
        self.Name = _cast(None, Name)
        self.Header = Header
        self.Parameterliste = Parameterliste
        self.Korpusdaten = Korpusdaten
        self.Oberboden = Oberboden
        self.Unterboden = Unterboden
        self.LinkeSeitenwand = LinkeSeitenwand
        self.RechteSeitenwand = RechteSeitenwand
        self.KorpusRueckwand = KorpusRueckwand
        self.Platten = Platten
        if KorpusAnbindung is None:
            self.KorpusAnbindung = []
        else:
            self.KorpusAnbindung = KorpusAnbindung
        if Tuer is None:
            self.Tuer = []
        else:
            self.Tuer = Tuer
        if Doppeltuer is None:
            self.Doppeltuer = []
        else:
            self.Doppeltuer = Doppeltuer
        if Blindfront is None:
            self.Blindfront = []
        else:
            self.Blindfront = Blindfront
        if Aussenschubkasten is None:
            self.Aussenschubkasten = []
        else:
            self.Aussenschubkasten = Aussenschubkasten
        if Innenschubkasten is None:
            self.Innenschubkasten = []
        else:
            self.Innenschubkasten = Innenschubkasten
        if Traverse is None:
            self.Traverse = []
        else:
            self.Traverse = Traverse
        if Klappensystem is None:
            self.Klappensystem = []
        else:
            self.Klappensystem = Klappensystem
        if InnenFach is None:
            self.InnenFach = []
        else:
            self.InnenFach = InnenFach
        if OffenesFach is None:
            self.OffenesFach = []
        else:
            self.OffenesFach = OffenesFach
        if Vorratsauszug is None:
            self.Vorratsauszug = []
        else:
            self.Vorratsauszug = Vorratsauszug
        if SERVODRIVE is None:
            self.SERVODRIVE = []
        else:
            self.SERVODRIVE = SERVODRIVE
    def factory(*args_, **kwargs_):
        if Korpus.subclass:
            return Korpus.subclass(*args_, **kwargs_)
        else:
            return Korpus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Header(self): return self.Header
    def set_Header(self, Header): self.Header = Header
    def get_Parameterliste(self): return self.Parameterliste
    def set_Parameterliste(self, Parameterliste): self.Parameterliste = Parameterliste
    def get_Korpusdaten(self): return self.Korpusdaten
    def set_Korpusdaten(self, Korpusdaten): self.Korpusdaten = Korpusdaten
    def get_Oberboden(self): return self.Oberboden
    def set_Oberboden(self, Oberboden): self.Oberboden = Oberboden
    def get_Unterboden(self): return self.Unterboden
    def set_Unterboden(self, Unterboden): self.Unterboden = Unterboden
    def get_LinkeSeitenwand(self): return self.LinkeSeitenwand
    def set_LinkeSeitenwand(self, LinkeSeitenwand): self.LinkeSeitenwand = LinkeSeitenwand
    def get_RechteSeitenwand(self): return self.RechteSeitenwand
    def set_RechteSeitenwand(self, RechteSeitenwand): self.RechteSeitenwand = RechteSeitenwand
    def get_KorpusRueckwand(self): return self.KorpusRueckwand
    def set_KorpusRueckwand(self, KorpusRueckwand): self.KorpusRueckwand = KorpusRueckwand
    def get_Platten(self): return self.Platten
    def set_Platten(self, Platten): self.Platten = Platten
    def get_KorpusAnbindung(self): return self.KorpusAnbindung
    def set_KorpusAnbindung(self, KorpusAnbindung): self.KorpusAnbindung = KorpusAnbindung
    def add_KorpusAnbindung(self, value): self.KorpusAnbindung.append(value)
    def insert_KorpusAnbindung(self, index, value): self.KorpusAnbindung[index] = value
    def get_Tuer(self): return self.Tuer
    def set_Tuer(self, Tuer): self.Tuer = Tuer
    def add_Tuer(self, value): self.Tuer.append(value)
    def insert_Tuer(self, index, value): self.Tuer[index] = value
    def get_Doppeltuer(self): return self.Doppeltuer
    def set_Doppeltuer(self, Doppeltuer): self.Doppeltuer = Doppeltuer
    def add_Doppeltuer(self, value): self.Doppeltuer.append(value)
    def insert_Doppeltuer(self, index, value): self.Doppeltuer[index] = value
    def get_Blindfront(self): return self.Blindfront
    def set_Blindfront(self, Blindfront): self.Blindfront = Blindfront
    def add_Blindfront(self, value): self.Blindfront.append(value)
    def insert_Blindfront(self, index, value): self.Blindfront[index] = value
    def get_Aussenschubkasten(self): return self.Aussenschubkasten
    def set_Aussenschubkasten(self, Aussenschubkasten): self.Aussenschubkasten = Aussenschubkasten
    def add_Aussenschubkasten(self, value): self.Aussenschubkasten.append(value)
    def insert_Aussenschubkasten(self, index, value): self.Aussenschubkasten[index] = value
    def get_Innenschubkasten(self): return self.Innenschubkasten
    def set_Innenschubkasten(self, Innenschubkasten): self.Innenschubkasten = Innenschubkasten
    def add_Innenschubkasten(self, value): self.Innenschubkasten.append(value)
    def insert_Innenschubkasten(self, index, value): self.Innenschubkasten[index] = value
    def get_Traverse(self): return self.Traverse
    def set_Traverse(self, Traverse): self.Traverse = Traverse
    def add_Traverse(self, value): self.Traverse.append(value)
    def insert_Traverse(self, index, value): self.Traverse[index] = value
    def get_Klappensystem(self): return self.Klappensystem
    def set_Klappensystem(self, Klappensystem): self.Klappensystem = Klappensystem
    def add_Klappensystem(self, value): self.Klappensystem.append(value)
    def insert_Klappensystem(self, index, value): self.Klappensystem[index] = value
    def get_InnenFach(self): return self.InnenFach
    def set_InnenFach(self, InnenFach): self.InnenFach = InnenFach
    def add_InnenFach(self, value): self.InnenFach.append(value)
    def insert_InnenFach(self, index, value): self.InnenFach[index] = value
    def get_OffenesFach(self): return self.OffenesFach
    def set_OffenesFach(self, OffenesFach): self.OffenesFach = OffenesFach
    def add_OffenesFach(self, value): self.OffenesFach.append(value)
    def insert_OffenesFach(self, index, value): self.OffenesFach[index] = value
    def get_Vorratsauszug(self): return self.Vorratsauszug
    def set_Vorratsauszug(self, Vorratsauszug): self.Vorratsauszug = Vorratsauszug
    def add_Vorratsauszug(self, value): self.Vorratsauszug.append(value)
    def insert_Vorratsauszug(self, index, value): self.Vorratsauszug[index] = value
    def get_SERVODRIVE(self): return self.SERVODRIVE
    def set_SERVODRIVE(self, SERVODRIVE): self.SERVODRIVE = SERVODRIVE
    def add_SERVODRIVE(self, value): self.SERVODRIVE.append(value)
    def insert_SERVODRIVE(self, index, value): self.SERVODRIVE[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def export(self, outfile, level, namespace_='', name_='Korpus', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Korpus')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
            self.GroupChildObjectK3() # For K3Mebel add
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Korpus'):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Korpus', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Header is not None:
            self.Header.export(outfile, level, namespace_, name_='Header', pretty_print=pretty_print)
        if self.Parameterliste is not None:
            self.Parameterliste.export(outfile, level, namespace_, name_='Parameterliste', pretty_print=pretty_print)
        if self.Korpusdaten is not None:
            self.Korpusdaten.export(outfile, level, namespace_, name_='Korpusdaten', pretty_print=pretty_print)
        if self.Oberboden is not None:
            self.Oberboden.export(outfile, level, namespace_, name_='Oberboden', pretty_print=pretty_print)
        if self.Unterboden is not None:
            self.Unterboden.export(outfile, level, namespace_, name_='Unterboden', pretty_print=pretty_print)
        if self.LinkeSeitenwand is not None:
            self.LinkeSeitenwand.export(outfile, level, namespace_, name_='LinkeSeitenwand', pretty_print=pretty_print)
        if self.RechteSeitenwand is not None:
            self.RechteSeitenwand.export(outfile, level, namespace_, name_='RechteSeitenwand', pretty_print=pretty_print)
        if self.KorpusRueckwand is not None:
            self.KorpusRueckwand.export(outfile, level, namespace_, name_='KorpusRueckwand', pretty_print=pretty_print)
        if self.Platten is not None:
            self.Platten.export(outfile, level, namespace_, name_='Platten', pretty_print=pretty_print)
        for KorpusAnbindung_ in self.KorpusAnbindung:
            KorpusAnbindung_.export(outfile, level, namespace_, name_='KorpusAnbindung', pretty_print=pretty_print)
        for Tuer_ in self.Tuer:
            Tuer_.export(outfile, level, namespace_, name_='Tuer', pretty_print=pretty_print)
        for Doppeltuer_ in self.Doppeltuer:
            Doppeltuer_.export(outfile, level, namespace_, name_='Doppeltuer', pretty_print=pretty_print)
        for Blindfront_ in self.Blindfront:
            Blindfront_.export(outfile, level, namespace_, name_='Blindfront', pretty_print=pretty_print)
        for Aussenschubkasten_ in self.Aussenschubkasten:
            Aussenschubkasten_.export(outfile, level, namespace_, name_='Aussenschubkasten', pretty_print=pretty_print)
        for Innenschubkasten_ in self.Innenschubkasten:
            Innenschubkasten_.export(outfile, level, namespace_, name_='Innenschubkasten', pretty_print=pretty_print)
        for Traverse_ in self.Traverse:
            Traverse_.export(outfile, level, namespace_, name_='Traverse', pretty_print=pretty_print)
        for Klappensystem_ in self.Klappensystem:
            Klappensystem_.export(outfile, level, namespace_, name_='Klappensystem', pretty_print=pretty_print)
        for InnenFach_ in self.InnenFach:
            InnenFach_.export(outfile, level, namespace_, name_='InnenFach', pretty_print=pretty_print)
        for OffenesFach_ in self.OffenesFach:
            OffenesFach_.export(outfile, level, namespace_, name_='OffenesFach', pretty_print=pretty_print)
        for Vorratsauszug_ in self.Vorratsauszug:
            Vorratsauszug_.export(outfile, level, namespace_, name_='Vorratsauszug', pretty_print=pretty_print)
        for SERVODRIVE_ in self.SERVODRIVE:
            SERVODRIVE_.export(outfile, level, namespace_, name_='SERVODRIVE', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Header is not None or
            self.Parameterliste is not None or
            self.Korpusdaten is not None or
            self.Oberboden is not None or
            self.Unterboden is not None or
            self.LinkeSeitenwand is not None or
            self.RechteSeitenwand is not None or
            self.KorpusRueckwand is not None or
            self.Platten is not None or
            self.KorpusAnbindung or
            self.Tuer or
            self.Doppeltuer or
            self.Blindfront or
            self.Aussenschubkasten or
            self.Innenschubkasten or
            self.Traverse or
            self.Klappensystem or
            self.InnenFach or
            self.OffenesFach or
            self.Vorratsauszug or
            self.SERVODRIVE
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Korpus'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Header is not None:
            showIndent(outfile, level)
            outfile.write('Header=model_.HeaderType(\n')
            self.Header.exportLiteral(outfile, level, name_='Header')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Parameterliste is not None:
            showIndent(outfile, level)
            outfile.write('Parameterliste=model_.ParameterlisteType(\n')
            self.Parameterliste.exportLiteral(outfile, level, name_='Parameterliste')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Korpusdaten is not None:
            showIndent(outfile, level)
            outfile.write('Korpusdaten=model_.KorpusdatenType(\n')
            self.Korpusdaten.exportLiteral(outfile, level, name_='Korpusdaten')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Oberboden is not None:
            showIndent(outfile, level)
            outfile.write('Oberboden=model_.BodenType(\n')
            self.Oberboden.exportLiteral(outfile, level, name_='Oberboden')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Unterboden is not None:
            showIndent(outfile, level)
            outfile.write('Unterboden=model_.BodenType(\n')
            self.Unterboden.exportLiteral(outfile, level, name_='Unterboden')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LinkeSeitenwand is not None:
            showIndent(outfile, level)
            outfile.write('LinkeSeitenwand=model_.SeitenwandType(\n')
            self.LinkeSeitenwand.exportLiteral(outfile, level, name_='LinkeSeitenwand')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RechteSeitenwand is not None:
            showIndent(outfile, level)
            outfile.write('RechteSeitenwand=model_.SeitenwandType(\n')
            self.RechteSeitenwand.exportLiteral(outfile, level, name_='RechteSeitenwand')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.KorpusRueckwand is not None:
            showIndent(outfile, level)
            outfile.write('KorpusRueckwand=model_.RueckwandListType(\n')
            self.KorpusRueckwand.exportLiteral(outfile, level, name_='KorpusRueckwand')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Platten is not None:
            showIndent(outfile, level)
            outfile.write('Platten=model_.PlattenType(\n')
            self.Platten.exportLiteral(outfile, level, name_='Platten')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('KorpusAnbindung=[\n')
        level += 1
        for KorpusAnbindung_ in self.KorpusAnbindung:
            showIndent(outfile, level)
            outfile.write('model_.KorpusAnbindungType(\n')
            KorpusAnbindung_.exportLiteral(outfile, level, name_='KorpusAnbindungType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Tuer=[\n')
        level += 1
        for Tuer_ in self.Tuer:
            showIndent(outfile, level)
            outfile.write('model_.TuerType(\n')
            Tuer_.exportLiteral(outfile, level, name_='TuerType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Doppeltuer=[\n')
        level += 1
        for Doppeltuer_ in self.Doppeltuer:
            showIndent(outfile, level)
            outfile.write('model_.DoppeltuerType(\n')
            Doppeltuer_.exportLiteral(outfile, level, name_='DoppeltuerType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Blindfront=[\n')
        level += 1
        for Blindfront_ in self.Blindfront:
            showIndent(outfile, level)
            outfile.write('model_.BlindfrontType(\n')
            Blindfront_.exportLiteral(outfile, level, name_='BlindfrontType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Aussenschubkasten=[\n')
        level += 1
        for Aussenschubkasten_ in self.Aussenschubkasten:
            showIndent(outfile, level)
            outfile.write('model_.AussenschubkastenType(\n')
            Aussenschubkasten_.exportLiteral(outfile, level, name_='AussenschubkastenType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Innenschubkasten=[\n')
        level += 1
        for Innenschubkasten_ in self.Innenschubkasten:
            showIndent(outfile, level)
            outfile.write('model_.InnenschubkastenType(\n')
            Innenschubkasten_.exportLiteral(outfile, level, name_='InnenschubkastenType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Traverse=[\n')
        level += 1
        for Traverse_ in self.Traverse:
            showIndent(outfile, level)
            outfile.write('model_.TraverseType(\n')
            Traverse_.exportLiteral(outfile, level, name_='TraverseType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Klappensystem=[\n')
        level += 1
        for Klappensystem_ in self.Klappensystem:
            showIndent(outfile, level)
            outfile.write('model_.KlappensystemType(\n')
            Klappensystem_.exportLiteral(outfile, level, name_='KlappensystemType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('InnenFach=[\n')
        level += 1
        for InnenFach_ in self.InnenFach:
            showIndent(outfile, level)
            outfile.write('model_.InnenFachType(\n')
            InnenFach_.exportLiteral(outfile, level, name_='InnenFachType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('OffenesFach=[\n')
        level += 1
        for OffenesFach_ in self.OffenesFach:
            showIndent(outfile, level)
            outfile.write('model_.FachType(\n')
            OffenesFach_.exportLiteral(outfile, level, name_='FachType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Vorratsauszug=[\n')
        level += 1
        for Vorratsauszug_ in self.Vorratsauszug:
            showIndent(outfile, level)
            outfile.write('model_.VorratsauszugType(\n')
            Vorratsauszug_.exportLiteral(outfile, level, name_='VorratsauszugType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SERVODRIVE=[\n')
        level += 1
        for SERVODRIVE_ in self.SERVODRIVE:
            showIndent(outfile, level)
            outfile.write('model_.SERVODRIVEType(\n')
            SERVODRIVE_.exportLiteral(outfile, level, name_='SERVODRIVEType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Header':
            obj_ = HeaderType.factory()
            obj_.build(child_)
            self.set_Header(obj_)
        elif nodeName_ == 'Parameterliste':
            obj_ = ParameterlisteType.factory()
            obj_.build(child_)
            self.set_Parameterliste(obj_)
        elif nodeName_ == 'Korpusdaten':
            obj_ = KorpusdatenType.factory()
            obj_.build(child_)
            self.set_Korpusdaten(obj_)
        elif nodeName_ == 'Oberboden':
            obj_ = BodenType.factory()
            obj_.build(child_)
            self.set_Oberboden(obj_)
        elif nodeName_ == 'Unterboden':
            obj_ = BodenType.factory()
            obj_.build(child_)
            self.set_Unterboden(obj_)
        elif nodeName_ == 'LinkeSeitenwand':
            obj_ = SeitenwandType.factory()
            obj_.build(child_)
            self.set_LinkeSeitenwand(obj_)
        elif nodeName_ == 'RechteSeitenwand':
            obj_ = SeitenwandType.factory()
            obj_.build(child_)
            self.set_RechteSeitenwand(obj_)
        elif nodeName_ == 'KorpusRueckwand':
            obj_ = RueckwandListType.factory()
            obj_.build(child_)
            self.set_KorpusRueckwand(obj_)
        elif nodeName_ == 'Platten':
            obj_ = PlattenType.factory()
            obj_.build(child_)
            self.set_Platten(obj_)
        elif nodeName_ == 'KorpusAnbindung':
            obj_ = KorpusAnbindungType.factory()
            obj_.build(child_)
            self.KorpusAnbindung.append(obj_)
        elif nodeName_ == 'Tuer':
            obj_ = TuerType.factory()
            obj_.build(child_)
            self.Tuer.append(obj_)
        elif nodeName_ == 'Doppeltuer':
            obj_ = DoppeltuerType.factory()
            obj_.build(child_)
            self.Doppeltuer.append(obj_)
        elif nodeName_ == 'Blindfront':
            obj_ = BlindfrontType.factory()
            obj_.build(child_)
            self.Blindfront.append(obj_)
        elif nodeName_ == 'Aussenschubkasten':
            obj_ = AussenschubkastenType.factory()
            obj_.build(child_)
            self.Aussenschubkasten.append(obj_)
        elif nodeName_ == 'Innenschubkasten':
            obj_ = InnenschubkastenType.factory()
            obj_.build(child_)
            self.Innenschubkasten.append(obj_)
        elif nodeName_ == 'Traverse':
            obj_ = TraverseType.factory()
            obj_.build(child_)
            self.Traverse.append(obj_)
        elif nodeName_ == 'Klappensystem':
            obj_ = KlappensystemType.factory()
            obj_.build(child_)
            self.Klappensystem.append(obj_)
        elif nodeName_ == 'InnenFach':
            obj_ = InnenFachType.factory()
            obj_.build(child_)
            self.InnenFach.append(obj_)
        elif nodeName_ == 'OffenesFach':
            obj_ = FachType.factory()
            obj_.build(child_)
            self.OffenesFach.append(obj_)
        elif nodeName_ == 'Vorratsauszug':
            obj_ = VorratsauszugType.factory()
            obj_.build(child_)
            self.Vorratsauszug.append(obj_)
        elif nodeName_ == 'SERVODRIVE':
            obj_ = SERVODRIVEType.factory()
            obj_.build(child_)
            self.SERVODRIVE.append(obj_)
# end class Korpus


class HeaderType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, BXFVersion=None, Datum=None, Ersteller=None, Attribut=None):
        self.BXFVersion = _cast(None, BXFVersion)
        self.Datum = _cast(None, Datum)
        self.Ersteller = _cast(None, Ersteller)
        if Attribut is None:
            self.Attribut = []
        else:
            self.Attribut = Attribut
    def factory(*args_, **kwargs_):
        if HeaderType.subclass:
            return HeaderType.subclass(*args_, **kwargs_)
        else:
            return HeaderType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Attribut(self): return self.Attribut
    def set_Attribut(self, Attribut): self.Attribut = Attribut
    def add_Attribut(self, value): self.Attribut.append(value)
    def insert_Attribut(self, index, value): self.Attribut[index] = value
    def get_BXFVersion(self): return self.BXFVersion
    def set_BXFVersion(self, BXFVersion): self.BXFVersion = BXFVersion
    def get_Datum(self): return self.Datum
    def set_Datum(self, Datum): self.Datum = Datum
    def get_Ersteller(self): return self.Ersteller
    def set_Ersteller(self, Ersteller): self.Ersteller = Ersteller
    def export(self, outfile, level, namespace_='', name_='HeaderType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HeaderType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HeaderType'):
        if self.BXFVersion is not None and 'BXFVersion' not in already_processed:
            already_processed.append('BXFVersion')
            outfile.write(' BXFVersion=%s' % (self.gds_format_string(quote_attrib(self.BXFVersion), input_name='BXFVersion'), ))
        if self.Datum is not None and 'Datum' not in already_processed:
            already_processed.append('Datum')
            outfile.write(' Datum=%s' % (self.gds_format_string(quote_attrib(self.Datum), input_name='Datum'), ))
        if self.Ersteller is not None and 'Ersteller' not in already_processed:
            already_processed.append('Ersteller')
            outfile.write(' Ersteller=%s' % (self.gds_format_string(quote_attrib(self.Ersteller), input_name='Ersteller'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='HeaderType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Attribut_ in self.Attribut:
            Attribut_.export(outfile, level, namespace_, name_='Attribut', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Attribut
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='HeaderType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.BXFVersion is not None and 'BXFVersion' not in already_processed:
            already_processed.append('BXFVersion')
            showIndent(outfile, level)
            outfile.write('BXFVersion = "%s",\n' % (self.BXFVersion,))
        if self.Datum is not None and 'Datum' not in already_processed:
            already_processed.append('Datum')
            showIndent(outfile, level)
            outfile.write('Datum = "%s",\n' % (self.Datum,))
        if self.Ersteller is not None and 'Ersteller' not in already_processed:
            already_processed.append('Ersteller')
            showIndent(outfile, level)
            outfile.write('Ersteller = "%s",\n' % (self.Ersteller,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Attribut=[\n')
        level += 1
        for Attribut_ in self.Attribut:
            showIndent(outfile, level)
            outfile.write('model_.AttributType(\n')
            Attribut_.exportLiteral(outfile, level, name_='AttributType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('BXFVersion', node)
        if value is not None and 'BXFVersion' not in already_processed:
            already_processed.append('BXFVersion')
            self.BXFVersion = value
        value = find_attr_value_('Datum', node)
        if value is not None and 'Datum' not in already_processed:
            already_processed.append('Datum')
            self.Datum = value
        value = find_attr_value_('Ersteller', node)
        if value is not None and 'Ersteller' not in already_processed:
            already_processed.append('Ersteller')
            self.Ersteller = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Attribut':
            obj_ = AttributType.factory()
            obj_.build(child_)
            self.Attribut.append(obj_)
# end class HeaderType


class ParameterlisteType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DSKorpus=None, Korpusinformationen=None, Anwendungsinformationen=None, Sonderregeln=None):
        if DSKorpus is None:
            self.DSKorpus = []
        else:
            self.DSKorpus = DSKorpus
        if Korpusinformationen is None:
            self.Korpusinformationen = []
        else:
            self.Korpusinformationen = Korpusinformationen
        if Anwendungsinformationen is None:
            self.Anwendungsinformationen = []
        else:
            self.Anwendungsinformationen = Anwendungsinformationen
        if Sonderregeln is None:
            self.Sonderregeln = []
        else:
            self.Sonderregeln = Sonderregeln
    def factory(*args_, **kwargs_):
        if ParameterlisteType.subclass:
            return ParameterlisteType.subclass(*args_, **kwargs_)
        else:
            return ParameterlisteType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DSKorpus(self): return self.DSKorpus
    def set_DSKorpus(self, DSKorpus): self.DSKorpus = DSKorpus
    def add_DSKorpus(self, value): self.DSKorpus.append(value)
    def insert_DSKorpus(self, index, value): self.DSKorpus[index] = value
    def get_Korpusinformationen(self): return self.Korpusinformationen
    def set_Korpusinformationen(self, Korpusinformationen): self.Korpusinformationen = Korpusinformationen
    def add_Korpusinformationen(self, value): self.Korpusinformationen.append(value)
    def insert_Korpusinformationen(self, index, value): self.Korpusinformationen[index] = value
    def get_Anwendungsinformationen(self): return self.Anwendungsinformationen
    def set_Anwendungsinformationen(self, Anwendungsinformationen): self.Anwendungsinformationen = Anwendungsinformationen
    def add_Anwendungsinformationen(self, value): self.Anwendungsinformationen.append(value)
    def insert_Anwendungsinformationen(self, index, value): self.Anwendungsinformationen[index] = value
    def get_Sonderregeln(self): return self.Sonderregeln
    def set_Sonderregeln(self, Sonderregeln): self.Sonderregeln = Sonderregeln
    def add_Sonderregeln(self, value): self.Sonderregeln.append(value)
    def insert_Sonderregeln(self, index, value): self.Sonderregeln[index] = value
    def export(self, outfile, level, namespace_='', name_='ParameterlisteType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ParameterlisteType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ParameterlisteType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ParameterlisteType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DSKorpus_ in self.DSKorpus:
            DSKorpus_.export(outfile, level, namespace_, name_='DSKorpus', pretty_print=pretty_print)
        for Korpusinformationen_ in self.Korpusinformationen:
            Korpusinformationen_.export(outfile, level, namespace_, name_='Korpusinformationen', pretty_print=pretty_print)
        for Anwendungsinformationen_ in self.Anwendungsinformationen:
            Anwendungsinformationen_.export(outfile, level, namespace_, name_='Anwendungsinformationen', pretty_print=pretty_print)
        for Sonderregeln_ in self.Sonderregeln:
            Sonderregeln_.export(outfile, level, namespace_, name_='Sonderregeln', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.DSKorpus or
            self.Korpusinformationen or
            self.Anwendungsinformationen or
            self.Sonderregeln
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ParameterlisteType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DSKorpus=[\n')
        level += 1
        for DSKorpus_ in self.DSKorpus:
            showIndent(outfile, level)
            outfile.write('model_.AttributeListType(\n')
            DSKorpus_.exportLiteral(outfile, level, name_='AttributeListType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Korpusinformationen=[\n')
        level += 1
        for Korpusinformationen_ in self.Korpusinformationen:
            showIndent(outfile, level)
            outfile.write('model_.KorpusinformationenType(\n')
            Korpusinformationen_.exportLiteral(outfile, level, name_='KorpusinformationenType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Anwendungsinformationen=[\n')
        level += 1
        for Anwendungsinformationen_ in self.Anwendungsinformationen:
            showIndent(outfile, level)
            outfile.write('model_.AnwendungsinformationenType(\n')
            Anwendungsinformationen_.exportLiteral(outfile, level, name_='AnwendungsinformationenType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Sonderregeln=[\n')
        level += 1
        for Sonderregeln_ in self.Sonderregeln:
            showIndent(outfile, level)
            outfile.write('model_.AttributeListType(\n')
            Sonderregeln_.exportLiteral(outfile, level, name_='AttributeListType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DSKorpus':
            obj_ = AttributeListType.factory()
            obj_.build(child_)
            self.DSKorpus.append(obj_)
        elif nodeName_ == 'Korpusinformationen':
            obj_ = KorpusinformationenType.factory()
            obj_.build(child_)
            self.Korpusinformationen.append(obj_)
        elif nodeName_ == 'Anwendungsinformationen':
            obj_ = AnwendungsinformationenType.factory()
            obj_.build(child_)
            self.Anwendungsinformationen.append(obj_)
        elif nodeName_ == 'Sonderregeln':
            obj_ = AttributeListType.factory()
            obj_.build(child_)
            self.Sonderregeln.append(obj_)
# end class ParameterlisteType


class KorpusinformationenType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Attribut=None, Oberbodenkonstruktion=None, Rueckwandkonstruktion=None):
        if Attribut is None:
            self.Attribut = []
        else:
            self.Attribut = Attribut
        if Oberbodenkonstruktion is None:
            self.Oberbodenkonstruktion = []
        else:
            self.Oberbodenkonstruktion = Oberbodenkonstruktion
        if Rueckwandkonstruktion is None:
            self.Rueckwandkonstruktion = []
        else:
            self.Rueckwandkonstruktion = Rueckwandkonstruktion
    def factory(*args_, **kwargs_):
        if KorpusinformationenType.subclass:
            return KorpusinformationenType.subclass(*args_, **kwargs_)
        else:
            return KorpusinformationenType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Attribut(self): return self.Attribut
    def set_Attribut(self, Attribut): self.Attribut = Attribut
    def add_Attribut(self, value): self.Attribut.append(value)
    def insert_Attribut(self, index, value): self.Attribut[index] = value
    def get_Oberbodenkonstruktion(self): return self.Oberbodenkonstruktion
    def set_Oberbodenkonstruktion(self, Oberbodenkonstruktion): self.Oberbodenkonstruktion = Oberbodenkonstruktion
    def add_Oberbodenkonstruktion(self, value): self.Oberbodenkonstruktion.append(value)
    def insert_Oberbodenkonstruktion(self, index, value): self.Oberbodenkonstruktion[index] = value
    def get_Rueckwandkonstruktion(self): return self.Rueckwandkonstruktion
    def set_Rueckwandkonstruktion(self, Rueckwandkonstruktion): self.Rueckwandkonstruktion = Rueckwandkonstruktion
    def add_Rueckwandkonstruktion(self, value): self.Rueckwandkonstruktion.append(value)
    def insert_Rueckwandkonstruktion(self, index, value): self.Rueckwandkonstruktion[index] = value
    def export(self, outfile, level, namespace_='', name_='KorpusinformationenType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KorpusinformationenType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='KorpusinformationenType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='KorpusinformationenType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Attribut_ in self.Attribut:
            Attribut_.export(outfile, level, namespace_, name_='Attribut', pretty_print=pretty_print)
        for Oberbodenkonstruktion_ in self.Oberbodenkonstruktion:
            Oberbodenkonstruktion_.export(outfile, level, namespace_, name_='Oberbodenkonstruktion', pretty_print=pretty_print)
        for Rueckwandkonstruktion_ in self.Rueckwandkonstruktion:
            Rueckwandkonstruktion_.export(outfile, level, namespace_, name_='Rueckwandkonstruktion', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Attribut or
            self.Oberbodenkonstruktion or
            self.Rueckwandkonstruktion
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='KorpusinformationenType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Attribut=[\n')
        level += 1
        for Attribut_ in self.Attribut:
            showIndent(outfile, level)
            outfile.write('model_.AttributType(\n')
            Attribut_.exportLiteral(outfile, level, name_='AttributType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Oberbodenkonstruktion=[\n')
        level += 1
        for Oberbodenkonstruktion_ in self.Oberbodenkonstruktion:
            showIndent(outfile, level)
            outfile.write('model_.AttributeListType(\n')
            Oberbodenkonstruktion_.exportLiteral(outfile, level, name_='AttributeListType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Rueckwandkonstruktion=[\n')
        level += 1
        for Rueckwandkonstruktion_ in self.Rueckwandkonstruktion:
            showIndent(outfile, level)
            outfile.write('model_.AttributeListType(\n')
            Rueckwandkonstruktion_.exportLiteral(outfile, level, name_='AttributeListType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Attribut':
            obj_ = AttributType.factory()
            obj_.build(child_)
            self.Attribut.append(obj_)
        elif nodeName_ == 'Oberbodenkonstruktion':
            obj_ = AttributeListType.factory()
            obj_.build(child_)
            self.Oberbodenkonstruktion.append(obj_)
        elif nodeName_ == 'Rueckwandkonstruktion':
            obj_ = AttributeListType.factory()
            obj_.build(child_)
            self.Rueckwandkonstruktion.append(obj_)
# end class KorpusinformationenType


class AnwendungsinformationenType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Allgemein=None, Anwendung=None):
        if Allgemein is None:
            self.Allgemein = []
        else:
            self.Allgemein = Allgemein
        if Anwendung is None:
            self.Anwendung = []
        else:
            self.Anwendung = Anwendung
    def factory(*args_, **kwargs_):
        if AnwendungsinformationenType.subclass:
            return AnwendungsinformationenType.subclass(*args_, **kwargs_)
        else:
            return AnwendungsinformationenType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Allgemein(self): return self.Allgemein
    def set_Allgemein(self, Allgemein): self.Allgemein = Allgemein
    def add_Allgemein(self, value): self.Allgemein.append(value)
    def insert_Allgemein(self, index, value): self.Allgemein[index] = value
    def get_Anwendung(self): return self.Anwendung
    def set_Anwendung(self, Anwendung): self.Anwendung = Anwendung
    def add_Anwendung(self, value): self.Anwendung.append(value)
    def insert_Anwendung(self, index, value): self.Anwendung[index] = value
    def export(self, outfile, level, namespace_='', name_='AnwendungsinformationenType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnwendungsinformationenType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AnwendungsinformationenType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AnwendungsinformationenType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Allgemein_ in self.Allgemein:
            Allgemein_.export(outfile, level, namespace_, name_='Allgemein', pretty_print=pretty_print)
        for Anwendung_ in self.Anwendung:
            Anwendung_.export(outfile, level, namespace_, name_='Anwendung', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Allgemein or
            self.Anwendung
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AnwendungsinformationenType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Allgemein=[\n')
        level += 1
        for Allgemein_ in self.Allgemein:
            showIndent(outfile, level)
            outfile.write('model_.AttributeListType(\n')
            Allgemein_.exportLiteral(outfile, level, name_='AttributeListType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Anwendung=[\n')
        level += 1
        for Anwendung_ in self.Anwendung:
            showIndent(outfile, level)
            outfile.write('model_.AttributeListType(\n')
            Anwendung_.exportLiteral(outfile, level, name_='AttributeListType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Allgemein':
            obj_ = AttributeListType.factory()
            obj_.build(child_)
            self.Allgemein.append(obj_)
        elif nodeName_ == 'Anwendung':
            obj_ = AttributeListType.factory()
            obj_.build(child_)
            self.Anwendung.append(obj_)
# end class AnwendungsinformationenType


class AttributeListType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Art=None, Name=None, Attribut=None):
        self.Art = _cast(None, Art)
        self.Name = _cast(None, Name)
        if Attribut is None:
            self.Attribut = []
        else:
            self.Attribut = Attribut
    def factory(*args_, **kwargs_):
        if AttributeListType.subclass:
            return AttributeListType.subclass(*args_, **kwargs_)
        else:
            return AttributeListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Attribut(self): return self.Attribut
    def set_Attribut(self, Attribut): self.Attribut = Attribut
    def add_Attribut(self, value): self.Attribut.append(value)
    def insert_Attribut(self, index, value): self.Attribut[index] = value
    def get_Art(self): return self.Art
    def set_Art(self, Art): self.Art = Art
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def export(self, outfile, level, namespace_='', name_='AttributeListType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AttributeListType'):
        if self.Art is not None and 'Art' not in already_processed:
            already_processed.append('Art')
            outfile.write(' Art=%s' % (self.gds_format_string(quote_attrib(self.Art), input_name='Art'), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AttributeListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Attribut_ in self.Attribut:
            Attribut_.export(outfile, level, namespace_, name_='Attribut', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Attribut
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AttributeListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Art is not None and 'Art' not in already_processed:
            already_processed.append('Art')
            showIndent(outfile, level)
            outfile.write('Art = "%s",\n' % (self.Art,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Attribut=[\n')
        level += 1
        for Attribut_ in self.Attribut:
            showIndent(outfile, level)
            outfile.write('model_.AttributType(\n')
            Attribut_.exportLiteral(outfile, level, name_='AttributType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Art', node)
        if value is not None and 'Art' not in already_processed:
            already_processed.append('Art')
            self.Art = value
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Attribut':
            obj_ = AttributType.factory()
            obj_.build(child_)
            self.Attribut.append(obj_)
# end class AttributeListType


class KorpusdatenType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Fugendaten=None, Korpusdaten=None, Plattendicken=None):
        self.Fugendaten = Fugendaten
        self.Korpusdaten = Korpusdaten
        self.Plattendicken = Plattendicken
    def factory(*args_, **kwargs_):
        if KorpusdatenType.subclass:
            return KorpusdatenType.subclass(*args_, **kwargs_)
        else:
            return KorpusdatenType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Fugendaten(self): return self.Fugendaten
    def set_Fugendaten(self, Fugendaten): self.Fugendaten = Fugendaten
    def get_Korpusdaten(self): return self.Korpusdaten
    def set_Korpusdaten(self, Korpusdaten): self.Korpusdaten = Korpusdaten
    def get_Plattendicken(self): return self.Plattendicken
    def set_Plattendicken(self, Plattendicken): self.Plattendicken = Plattendicken
    def export(self, outfile, level, namespace_='', name_='KorpusdatenType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KorpusdatenType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='KorpusdatenType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='KorpusdatenType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Fugendaten is not None:
            self.Fugendaten.export(outfile, level, namespace_, name_='Fugendaten', pretty_print=pretty_print)
        if self.Korpusdaten is not None:
            self.Korpusdaten.export(outfile, level, namespace_, name_='Korpusdaten', pretty_print=pretty_print)
        if self.Plattendicken is not None:
            self.Plattendicken.export(outfile, level, namespace_, name_='Plattendicken', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Fugendaten is not None or
            self.Korpusdaten is not None or
            self.Plattendicken is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='KorpusdatenType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Fugendaten is not None:
            showIndent(outfile, level)
            outfile.write('Fugendaten=model_.FugendatenType(\n')
            self.Fugendaten.exportLiteral(outfile, level, name_='Fugendaten')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Korpusdaten is not None:
            showIndent(outfile, level)
            outfile.write('Korpusdaten=model_.KorpusdatenValuesType(\n')
            self.Korpusdaten.exportLiteral(outfile, level, name_='Korpusdaten')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Plattendicken is not None:
            showIndent(outfile, level)
            outfile.write('Plattendicken=model_.PlattendickenType(\n')
            self.Plattendicken.exportLiteral(outfile, level, name_='Plattendicken')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Fugendaten':
            obj_ = FugendatenType.factory()
            obj_.build(child_)
            self.set_Fugendaten(obj_)
        elif nodeName_ == 'Korpusdaten':
            obj_ = KorpusdatenValuesType.factory()
            obj_.build(child_)
            self.set_Korpusdaten(obj_)
        elif nodeName_ == 'Plattendicken':
            obj_ = PlattendickenType.factory()
            obj_.build(child_)
            self.set_Plattendicken(obj_)
# end class KorpusdatenType


class FugendatenType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Oben=None, Unten=None, Zwischen=None, Links=None, Rechts=None, valueOf_=None):
        self.Oben = _cast(float, Oben)
        self.Unten = _cast(float, Unten)
        self.Zwischen = _cast(float, Zwischen)
        self.Links = _cast(float, Links)
        self.Rechts = _cast(float, Rechts)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if FugendatenType.subclass:
            return FugendatenType.subclass(*args_, **kwargs_)
        else:
            return FugendatenType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Oben(self): return self.Oben
    def set_Oben(self, Oben): self.Oben = Oben
    def get_Unten(self): return self.Unten
    def set_Unten(self, Unten): self.Unten = Unten
    def get_Zwischen(self): return self.Zwischen
    def set_Zwischen(self, Zwischen): self.Zwischen = Zwischen
    def get_Links(self): return self.Links
    def set_Links(self, Links): self.Links = Links
    def get_Rechts(self): return self.Rechts
    def set_Rechts(self, Rechts): self.Rechts = Rechts
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='FugendatenType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FugendatenType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FugendatenType'):
        if self.Oben is not None and 'Oben' not in already_processed:
            already_processed.append('Oben')
            outfile.write(' Oben="%s"' % self.gds_format_float(self.Oben, input_name='Oben'))
        if self.Unten is not None and 'Unten' not in already_processed:
            already_processed.append('Unten')
            outfile.write(' Unten="%s"' % self.gds_format_float(self.Unten, input_name='Unten'))
        if self.Zwischen is not None and 'Zwischen' not in already_processed:
            already_processed.append('Zwischen')
            outfile.write(' Zwischen="%s"' % self.gds_format_float(self.Zwischen, input_name='Zwischen'))
        if self.Links is not None and 'Links' not in already_processed:
            already_processed.append('Links')
            outfile.write(' Links="%s"' % self.gds_format_float(self.Links, input_name='Links'))
        if self.Rechts is not None and 'Rechts' not in already_processed:
            already_processed.append('Rechts')
            outfile.write(' Rechts="%s"' % self.gds_format_float(self.Rechts, input_name='Rechts'))
    def exportChildren(self, outfile, level, namespace_='', name_='FugendatenType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FugendatenType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Oben is not None and 'Oben' not in already_processed:
            already_processed.append('Oben')
            showIndent(outfile, level)
            outfile.write('Oben = %e,\n' % (self.Oben,))
        if self.Unten is not None and 'Unten' not in already_processed:
            already_processed.append('Unten')
            showIndent(outfile, level)
            outfile.write('Unten = %e,\n' % (self.Unten,))
        if self.Zwischen is not None and 'Zwischen' not in already_processed:
            already_processed.append('Zwischen')
            showIndent(outfile, level)
            outfile.write('Zwischen = %e,\n' % (self.Zwischen,))
        if self.Links is not None and 'Links' not in already_processed:
            already_processed.append('Links')
            showIndent(outfile, level)
            outfile.write('Links = %e,\n' % (self.Links,))
        if self.Rechts is not None and 'Rechts' not in already_processed:
            already_processed.append('Rechts')
            showIndent(outfile, level)
            outfile.write('Rechts = %e,\n' % (self.Rechts,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Oben', node)
        if value is not None and 'Oben' not in already_processed:
            already_processed.append('Oben')
            try:
                self.Oben = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Oben): %s' % exp)
        value = find_attr_value_('Unten', node)
        if value is not None and 'Unten' not in already_processed:
            already_processed.append('Unten')
            try:
                self.Unten = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Unten): %s' % exp)
        value = find_attr_value_('Zwischen', node)
        if value is not None and 'Zwischen' not in already_processed:
            already_processed.append('Zwischen')
            try:
                self.Zwischen = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Zwischen): %s' % exp)
        value = find_attr_value_('Links', node)
        if value is not None and 'Links' not in already_processed:
            already_processed.append('Links')
            try:
                self.Links = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Links): %s' % exp)
        value = find_attr_value_('Rechts', node)
        if value is not None and 'Rechts' not in already_processed:
            already_processed.append('Rechts')
            try:
                self.Rechts = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Rechts): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FugendatenType


class KorpusdatenValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Kab=None, Kwi=None, Kh=None, Ekb=None, Ktr=None, Ktl=None, Lw=None, Lt=None, Pta=None, Fb=None, Kt=None, Ekt=None, Pm=None, valueOf_=None):
        self.Kab = _cast(float, Kab)
        self.Kwi = _cast(float, Kwi)
        self.Kh = _cast(float, Kh)
        self.Ekb = _cast(float, Ekb)
        self.Ktr = _cast(float, Ktr)
        self.Ktl = _cast(float, Ktl)
        self.Lw = _cast(float, Lw)
        self.Lt = _cast(float, Lt)
        self.Pta = _cast(float, Pta)
        self.Fb = _cast(float, Fb)
        self.Kt = _cast(float, Kt)
        self.Ekt = _cast(float, Ekt)
        self.Pm = _cast(float, Pm)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if KorpusdatenValuesType.subclass:
            return KorpusdatenValuesType.subclass(*args_, **kwargs_)
        else:
            return KorpusdatenValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Kab(self): return self.Kab
    def set_Kab(self, Kab): self.Kab = Kab
    def get_Kwi(self): return self.Kwi
    def set_Kwi(self, Kwi): self.Kwi = Kwi
    def get_Kh(self): return self.Kh
    def set_Kh(self, Kh): self.Kh = Kh
    def get_Ekb(self): return self.Ekb
    def set_Ekb(self, Ekb): self.Ekb = Ekb
    def get_Ktr(self): return self.Ktr
    def set_Ktr(self, Ktr): self.Ktr = Ktr
    def get_Ktl(self): return self.Ktl
    def set_Ktl(self, Ktl): self.Ktl = Ktl
    def get_Lw(self): return self.Lw
    def set_Lw(self, Lw): self.Lw = Lw
    def get_Lt(self): return self.Lt
    def set_Lt(self, Lt): self.Lt = Lt
    def get_Pta(self): return self.Pta
    def set_Pta(self, Pta): self.Pta = Pta
    def get_Fb(self): return self.Fb
    def set_Fb(self, Fb): self.Fb = Fb
    def get_Kt(self): return self.Kt
    def set_Kt(self, Kt): self.Kt = Kt
    def get_Ekt(self): return self.Ekt
    def set_Ekt(self, Ekt): self.Ekt = Ekt
    def get_Pm(self): return self.Pm
    def set_Pm(self, Pm): self.Pm = Pm
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='KorpusdatenValuesType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KorpusdatenValuesType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='KorpusdatenValuesType'):
        if self.Kab is not None and 'Kab' not in already_processed:
            already_processed.append('Kab')
            outfile.write(' Kab="%s"' % self.gds_format_float(self.Kab, input_name='Kab'))
        if self.Kwi is not None and 'Kwi' not in already_processed:
            already_processed.append('Kwi')
            outfile.write(' Kwi="%s"' % self.gds_format_float(self.Kwi, input_name='Kwi'))
        if self.Kh is not None and 'Kh' not in already_processed:
            already_processed.append('Kh')
            outfile.write(' Kh="%s"' % self.gds_format_float(self.Kh, input_name='Kh'))
        if self.Ekb is not None and 'Ekb' not in already_processed:
            already_processed.append('Ekb')
            outfile.write(' Ekb="%s"' % self.gds_format_float(self.Ekb, input_name='Ekb'))
        if self.Ktr is not None and 'Ktr' not in already_processed:
            already_processed.append('Ktr')
            outfile.write(' Ktr="%s"' % self.gds_format_float(self.Ktr, input_name='Ktr'))
        if self.Ktl is not None and 'Ktl' not in already_processed:
            already_processed.append('Ktl')
            outfile.write(' Ktl="%s"' % self.gds_format_float(self.Ktl, input_name='Ktl'))
        if self.Lw is not None and 'Lw' not in already_processed:
            already_processed.append('Lw')
            outfile.write(' Lw="%s"' % self.gds_format_float(self.Lw, input_name='Lw'))
        if self.Lt is not None and 'Lt' not in already_processed:
            already_processed.append('Lt')
            outfile.write(' Lt="%s"' % self.gds_format_float(self.Lt, input_name='Lt'))
        if self.Pta is not None and 'Pta' not in already_processed:
            already_processed.append('Pta')
            outfile.write(' Pta="%s"' % self.gds_format_float(self.Pta, input_name='Pta'))
        if self.Fb is not None and 'Fb' not in already_processed:
            already_processed.append('Fb')
            outfile.write(' Fb="%s"' % self.gds_format_float(self.Fb, input_name='Fb'))
        if self.Kt is not None and 'Kt' not in already_processed:
            already_processed.append('Kt')
            outfile.write(' Kt="%s"' % self.gds_format_float(self.Kt, input_name='Kt'))
        if self.Ekt is not None and 'Ekt' not in already_processed:
            already_processed.append('Ekt')
            outfile.write(' Ekt="%s"' % self.gds_format_float(self.Ekt, input_name='Ekt'))
        if self.Pm is not None and 'Pm' not in already_processed:
            already_processed.append('Pm')
            outfile.write(' Pm="%s"' % self.gds_format_float(self.Pm, input_name='Pm'))
    def exportChildren(self, outfile, level, namespace_='', name_='KorpusdatenValuesType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='KorpusdatenValuesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Kab is not None and 'Kab' not in already_processed:
            already_processed.append('Kab')
            showIndent(outfile, level)
            outfile.write('Kab = %e,\n' % (self.Kab,))
        if self.Kwi is not None and 'Kwi' not in already_processed:
            already_processed.append('Kwi')
            showIndent(outfile, level)
            outfile.write('Kwi = %e,\n' % (self.Kwi,))
        if self.Kh is not None and 'Kh' not in already_processed:
            already_processed.append('Kh')
            showIndent(outfile, level)
            outfile.write('Kh = %e,\n' % (self.Kh,))
        if self.Ekb is not None and 'Ekb' not in already_processed:
            already_processed.append('Ekb')
            showIndent(outfile, level)
            outfile.write('Ekb = %e,\n' % (self.Ekb,))
        if self.Ktr is not None and 'Ktr' not in already_processed:
            already_processed.append('Ktr')
            showIndent(outfile, level)
            outfile.write('Ktr = %e,\n' % (self.Ktr,))
        if self.Ktl is not None and 'Ktl' not in already_processed:
            already_processed.append('Ktl')
            showIndent(outfile, level)
            outfile.write('Ktl = %e,\n' % (self.Ktl,))
        if self.Lw is not None and 'Lw' not in already_processed:
            already_processed.append('Lw')
            showIndent(outfile, level)
            outfile.write('Lw = %e,\n' % (self.Lw,))
        if self.Lt is not None and 'Lt' not in already_processed:
            already_processed.append('Lt')
            showIndent(outfile, level)
            outfile.write('Lt = %e,\n' % (self.Lt,))
        if self.Pta is not None and 'Pta' not in already_processed:
            already_processed.append('Pta')
            showIndent(outfile, level)
            outfile.write('Pta = %e,\n' % (self.Pta,))
        if self.Fb is not None and 'Fb' not in already_processed:
            already_processed.append('Fb')
            showIndent(outfile, level)
            outfile.write('Fb = %e,\n' % (self.Fb,))
        if self.Kt is not None and 'Kt' not in already_processed:
            already_processed.append('Kt')
            showIndent(outfile, level)
            outfile.write('Kt = %e,\n' % (self.Kt,))
        if self.Ekt is not None and 'Ekt' not in already_processed:
            already_processed.append('Ekt')
            showIndent(outfile, level)
            outfile.write('Ekt = %e,\n' % (self.Ekt,))
        if self.Pm is not None and 'Pm' not in already_processed:
            already_processed.append('Pm')
            showIndent(outfile, level)
            outfile.write('Pm = %e,\n' % (self.Pm,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Kab', node)
        if value is not None and 'Kab' not in already_processed:
            already_processed.append('Kab')
            try:
                self.Kab = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Kab): %s' % exp)
        value = find_attr_value_('Kwi', node)
        if value is not None and 'Kwi' not in already_processed:
            already_processed.append('Kwi')
            try:
                self.Kwi = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Kwi): %s' % exp)
        value = find_attr_value_('Kh', node)
        if value is not None and 'Kh' not in already_processed:
            already_processed.append('Kh')
            try:
                self.Kh = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Kh): %s' % exp)
        value = find_attr_value_('Ekb', node)
        if value is not None and 'Ekb' not in already_processed:
            already_processed.append('Ekb')
            try:
                self.Ekb = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Ekb): %s' % exp)
        value = find_attr_value_('Ktr', node)
        if value is not None and 'Ktr' not in already_processed:
            already_processed.append('Ktr')
            try:
                self.Ktr = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Ktr): %s' % exp)
        value = find_attr_value_('Ktl', node)
        if value is not None and 'Ktl' not in already_processed:
            already_processed.append('Ktl')
            try:
                self.Ktl = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Ktl): %s' % exp)
        value = find_attr_value_('Lw', node)
        if value is not None and 'Lw' not in already_processed:
            already_processed.append('Lw')
            try:
                self.Lw = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Lw): %s' % exp)
        value = find_attr_value_('Lt', node)
        if value is not None and 'Lt' not in already_processed:
            already_processed.append('Lt')
            try:
                self.Lt = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Lt): %s' % exp)
        value = find_attr_value_('Pta', node)
        if value is not None and 'Pta' not in already_processed:
            already_processed.append('Pta')
            try:
                self.Pta = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Pta): %s' % exp)
        value = find_attr_value_('Fb', node)
        if value is not None and 'Fb' not in already_processed:
            already_processed.append('Fb')
            try:
                self.Fb = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Fb): %s' % exp)
        value = find_attr_value_('Kt', node)
        if value is not None and 'Kt' not in already_processed:
            already_processed.append('Kt')
            try:
                self.Kt = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Kt): %s' % exp)
        value = find_attr_value_('Ekt', node)
        if value is not None and 'Ekt' not in already_processed:
            already_processed.append('Ekt')
            try:
                self.Ekt = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Ekt): %s' % exp)
        value = find_attr_value_('Pm', node)
        if value is not None and 'Pm' not in already_processed:
            already_processed.append('Pm')
            try:
                self.Pm = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Pm): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class KorpusdatenValuesType


class PlattendickenType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Distd=None, Oben=None, Unten=None, Links=None, Rechts=None, valueOf_=None):
        self.Distd = _cast(float, Distd)
        self.Oben = _cast(float, Oben)
        self.Unten = _cast(float, Unten)
        self.Links = _cast(float, Links)
        self.Rechts = _cast(float, Rechts)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if PlattendickenType.subclass:
            return PlattendickenType.subclass(*args_, **kwargs_)
        else:
            return PlattendickenType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Distd(self): return self.Distd
    def set_Distd(self, Distd): self.Distd = Distd
    def get_Oben(self): return self.Oben
    def set_Oben(self, Oben): self.Oben = Oben
    def get_Unten(self): return self.Unten
    def set_Unten(self, Unten): self.Unten = Unten
    def get_Links(self): return self.Links
    def set_Links(self, Links): self.Links = Links
    def get_Rechts(self): return self.Rechts
    def set_Rechts(self, Rechts): self.Rechts = Rechts
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='PlattendickenType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PlattendickenType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PlattendickenType'):
        if self.Distd is not None and 'Distd' not in already_processed:
            already_processed.append('Distd')
            outfile.write(' Distd="%s"' % self.gds_format_float(self.Distd, input_name='Distd'))
        if self.Oben is not None and 'Oben' not in already_processed:
            already_processed.append('Oben')
            outfile.write(' Oben="%s"' % self.gds_format_float(self.Oben, input_name='Oben'))
        if self.Unten is not None and 'Unten' not in already_processed:
            already_processed.append('Unten')
            outfile.write(' Unten="%s"' % self.gds_format_float(self.Unten, input_name='Unten'))
        if self.Links is not None and 'Links' not in already_processed:
            already_processed.append('Links')
            outfile.write(' Links="%s"' % self.gds_format_float(self.Links, input_name='Links'))
        if self.Rechts is not None and 'Rechts' not in already_processed:
            already_processed.append('Rechts')
            outfile.write(' Rechts="%s"' % self.gds_format_float(self.Rechts, input_name='Rechts'))
    def exportChildren(self, outfile, level, namespace_='', name_='PlattendickenType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PlattendickenType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Distd is not None and 'Distd' not in already_processed:
            already_processed.append('Distd')
            showIndent(outfile, level)
            outfile.write('Distd = %e,\n' % (self.Distd,))
        if self.Oben is not None and 'Oben' not in already_processed:
            already_processed.append('Oben')
            showIndent(outfile, level)
            outfile.write('Oben = %e,\n' % (self.Oben,))
        if self.Unten is not None and 'Unten' not in already_processed:
            already_processed.append('Unten')
            showIndent(outfile, level)
            outfile.write('Unten = %e,\n' % (self.Unten,))
        if self.Links is not None and 'Links' not in already_processed:
            already_processed.append('Links')
            showIndent(outfile, level)
            outfile.write('Links = %e,\n' % (self.Links,))
        if self.Rechts is not None and 'Rechts' not in already_processed:
            already_processed.append('Rechts')
            showIndent(outfile, level)
            outfile.write('Rechts = %e,\n' % (self.Rechts,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Distd', node)
        if value is not None and 'Distd' not in already_processed:
            already_processed.append('Distd')
            try:
                self.Distd = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Distd): %s' % exp)
        value = find_attr_value_('Oben', node)
        if value is not None and 'Oben' not in already_processed:
            already_processed.append('Oben')
            try:
                self.Oben = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Oben): %s' % exp)
        value = find_attr_value_('Unten', node)
        if value is not None and 'Unten' not in already_processed:
            already_processed.append('Unten')
            try:
                self.Unten = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Unten): %s' % exp)
        value = find_attr_value_('Links', node)
        if value is not None and 'Links' not in already_processed:
            already_processed.append('Links')
            try:
                self.Links = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Links): %s' % exp)
        value = find_attr_value_('Rechts', node)
        if value is not None and 'Rechts' not in already_processed:
            already_processed.append('Rechts')
            try:
                self.Rechts = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Rechts): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PlattendickenType


class BodenType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Boden=None):
        if Boden is None:
            self.Boden = []
        else:
            self.Boden = Boden
    def factory(*args_, **kwargs_):
        if BodenType.subclass:
            return BodenType.subclass(*args_, **kwargs_)
        else:
            return BodenType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Boden(self): return self.Boden
    def set_Boden(self, Boden): self.Boden = Boden
    def add_Boden(self, value): self.Boden.append(value)
    def insert_Boden(self, index, value): self.Boden[index] = value
    def export(self, outfile, level, namespace_='', name_='BodenType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BodenType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BodenType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BodenType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Boden_ in self.Boden:
            Boden_.export(outfile, level, namespace_, name_='Boden', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Boden
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BodenType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Boden=[\n')
        level += 1
        for Boden_ in self.Boden:
            showIndent(outfile, level)
            outfile.write('model_.GeometryType(\n')
            Boden_.exportLiteral(outfile, level, name_='GeometryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Boden':
            class_obj_ = self.get_class_obj_(child_, GeometryType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Boden.append(obj_)
# end class BodenType


class SeitenwandType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Seitenwand=None, Eckkorpusseite=None):
        self.Seitenwand = Seitenwand
        if Eckkorpusseite is None:
            self.Eckkorpusseite = []
        else:
            self.Eckkorpusseite = Eckkorpusseite
    def factory(*args_, **kwargs_):
        if SeitenwandType.subclass:
            return SeitenwandType.subclass(*args_, **kwargs_)
        else:
            return SeitenwandType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Seitenwand(self): return self.Seitenwand
    def set_Seitenwand(self, Seitenwand): self.Seitenwand = Seitenwand
    def get_Eckkorpusseite(self): return self.Eckkorpusseite
    def set_Eckkorpusseite(self, Eckkorpusseite): self.Eckkorpusseite = Eckkorpusseite
    def add_Eckkorpusseite(self, value): self.Eckkorpusseite.append(value)
    def insert_Eckkorpusseite(self, index, value): self.Eckkorpusseite[index] = value
    def export(self, outfile, level, namespace_='', name_='SeitenwandType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SeitenwandType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SeitenwandType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SeitenwandType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Seitenwand is not None:
            self.Seitenwand.export(outfile, level, namespace_, name_='Seitenwand', pretty_print=pretty_print)
        for Eckkorpusseite_ in self.Eckkorpusseite:
            Eckkorpusseite_.export(outfile, level, namespace_, name_='Eckkorpusseite', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Seitenwand is not None or
            self.Eckkorpusseite
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SeitenwandType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Seitenwand is not None:
            showIndent(outfile, level)
            outfile.write('Seitenwand=model_.GeometryType(\n')
            self.Seitenwand.exportLiteral(outfile, level, name_='Seitenwand')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Eckkorpusseite=[\n')
        level += 1
        for Eckkorpusseite_ in self.Eckkorpusseite:
            showIndent(outfile, level)
            outfile.write('model_.GeometryType(\n')
            Eckkorpusseite_.exportLiteral(outfile, level, name_='GeometryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Seitenwand':
            class_obj_ = self.get_class_obj_(child_, GeometryType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_Seitenwand(obj_)
        elif nodeName_ == 'Eckkorpusseite':
            class_obj_ = self.get_class_obj_(child_, GeometryType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Eckkorpusseite.append(obj_)
# end class SeitenwandType


class RueckwandListType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Rueckwand=None, RueckwandVerbinder=None):
        if Rueckwand is None:
            self.Rueckwand = []
        else:
            self.Rueckwand = Rueckwand
        if RueckwandVerbinder is None:
            self.RueckwandVerbinder = []
        else:
            self.RueckwandVerbinder = RueckwandVerbinder
    def factory(*args_, **kwargs_):
        if RueckwandListType.subclass:
            return RueckwandListType.subclass(*args_, **kwargs_)
        else:
            return RueckwandListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Rueckwand(self): return self.Rueckwand
    def set_Rueckwand(self, Rueckwand): self.Rueckwand = Rueckwand
    def add_Rueckwand(self, value): self.Rueckwand.append(value)
    def insert_Rueckwand(self, index, value): self.Rueckwand[index] = value
    def get_RueckwandVerbinder(self): return self.RueckwandVerbinder
    def set_RueckwandVerbinder(self, RueckwandVerbinder): self.RueckwandVerbinder = RueckwandVerbinder
    def add_RueckwandVerbinder(self, value): self.RueckwandVerbinder.append(value)
    def insert_RueckwandVerbinder(self, index, value): self.RueckwandVerbinder[index] = value
    def export(self, outfile, level, namespace_='', name_='RueckwandListType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RueckwandListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RueckwandListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RueckwandListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Rueckwand_ in self.Rueckwand:
            Rueckwand_.export(outfile, level, namespace_, name_='Rueckwand', pretty_print=pretty_print)
        for RueckwandVerbinder_ in self.RueckwandVerbinder:
            RueckwandVerbinder_.export(outfile, level, namespace_, name_='RueckwandVerbinder', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Rueckwand or
            self.RueckwandVerbinder
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RueckwandListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Rueckwand=[\n')
        level += 1
        for Rueckwand_ in self.Rueckwand:
            showIndent(outfile, level)
            outfile.write('model_.GeometryType(\n')
            Rueckwand_.exportLiteral(outfile, level, name_='GeometryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('RueckwandVerbinder=[\n')
        level += 1
        for RueckwandVerbinder_ in self.RueckwandVerbinder:
            showIndent(outfile, level)
            outfile.write('model_.GeometryType(\n')
            RueckwandVerbinder_.exportLiteral(outfile, level, name_='GeometryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Rueckwand':
            class_obj_ = self.get_class_obj_(child_, GeometryType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Rueckwand.append(obj_)
        elif nodeName_ == 'RueckwandVerbinder':
            class_obj_ = self.get_class_obj_(child_, GeometryType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.RueckwandVerbinder.append(obj_)
# end class RueckwandListType


class PlattenType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Platte=None):
        if Platte is None:
            self.Platte = []
        else:
            self.Platte = Platte
    def factory(*args_, **kwargs_):
        if PlattenType.subclass:
            return PlattenType.subclass(*args_, **kwargs_)
        else:
            return PlattenType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Platte(self): return self.Platte
    def set_Platte(self, Platte): self.Platte = Platte
    def add_Platte(self, value): self.Platte.append(value)
    def insert_Platte(self, index, value): self.Platte[index] = value
    def export(self, outfile, level, namespace_='', name_='PlattenType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PlattenType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PlattenType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PlattenType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Platte_ in self.Platte:
            Platte_.export(outfile, level, namespace_, name_='Platte', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Platte
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PlattenType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Platte=[\n')
        level += 1
        for Platte_ in self.Platte:
            showIndent(outfile, level)
            outfile.write('model_.GeometryType(\n')
            Platte_.exportLiteral(outfile, level, name_='GeometryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Platte':
            class_obj_ = self.get_class_obj_(child_, GeometryType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Platte.append(obj_)
# end class PlattenType


class KorpusAnbindungType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Distanz=None, Keil=None):
        if Distanz is None:
            self.Distanz = []
        else:
            self.Distanz = Distanz
        if Keil is None:
            self.Keil = []
        else:
            self.Keil = Keil
    def factory(*args_, **kwargs_):
        if KorpusAnbindungType.subclass:
            return KorpusAnbindungType.subclass(*args_, **kwargs_)
        else:
            return KorpusAnbindungType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Distanz(self): return self.Distanz
    def set_Distanz(self, Distanz): self.Distanz = Distanz
    def add_Distanz(self, value): self.Distanz.append(value)
    def insert_Distanz(self, index, value): self.Distanz[index] = value
    def get_Keil(self): return self.Keil
    def set_Keil(self, Keil): self.Keil = Keil
    def add_Keil(self, value): self.Keil.append(value)
    def insert_Keil(self, index, value): self.Keil[index] = value
    def export(self, outfile, level, namespace_='', name_='KorpusAnbindungType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KorpusAnbindungType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='KorpusAnbindungType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='KorpusAnbindungType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Distanz_ in self.Distanz:
            Distanz_.export(outfile, level, namespace_, name_='Distanz', pretty_print=pretty_print)
        for Keil_ in self.Keil:
            Keil_.export(outfile, level, namespace_, name_='Keil', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Distanz or
            self.Keil
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='KorpusAnbindungType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Distanz=[\n')
        level += 1
        for Distanz_ in self.Distanz:
            showIndent(outfile, level)
            outfile.write('model_.GeometryType(\n')
            Distanz_.exportLiteral(outfile, level, name_='GeometryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Keil=[\n')
        level += 1
        for Keil_ in self.Keil:
            showIndent(outfile, level)
            outfile.write('model_.GeometryType(\n')
            Keil_.exportLiteral(outfile, level, name_='GeometryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Distanz':
            class_obj_ = self.get_class_obj_(child_, GeometryType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Distanz.append(obj_)
        elif nodeName_ == 'Keil':
            class_obj_ = self.get_class_obj_(child_, GeometryType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Keil.append(obj_)
# end class KorpusAnbindungType


class TuerType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ScharnierSeite=None, Name=None, Beschlaege=None, Front=None, Innenschubkasten=None, Traverse=None):
        self.ScharnierSeite = _cast(None, ScharnierSeite)
        self.Name = _cast(None, Name)
        self.Beschlaege = Beschlaege
        self.Front = Front
        if Innenschubkasten is None:
            self.Innenschubkasten = []
        else:
            self.Innenschubkasten = Innenschubkasten
        if Traverse is None:
            self.Traverse = []
        else:
            self.Traverse = Traverse
    def factory(*args_, **kwargs_):
        if TuerType.subclass:
            return TuerType.subclass(*args_, **kwargs_)
        else:
            return TuerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Beschlaege(self): return self.Beschlaege
    def set_Beschlaege(self, Beschlaege): self.Beschlaege = Beschlaege
    def get_Front(self): return self.Front
    def set_Front(self, Front): self.Front = Front
    def get_Innenschubkasten(self): return self.Innenschubkasten
    def set_Innenschubkasten(self, Innenschubkasten): self.Innenschubkasten = Innenschubkasten
    def add_Innenschubkasten(self, value): self.Innenschubkasten.append(value)
    def insert_Innenschubkasten(self, index, value): self.Innenschubkasten[index] = value
    def get_Traverse(self): return self.Traverse
    def set_Traverse(self, Traverse): self.Traverse = Traverse
    def add_Traverse(self, value): self.Traverse.append(value)
    def insert_Traverse(self, index, value): self.Traverse[index] = value
    def get_ScharnierSeite(self): return self.ScharnierSeite
    def set_ScharnierSeite(self, ScharnierSeite): self.ScharnierSeite = ScharnierSeite
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def export(self, outfile, level, namespace_='', name_='TuerType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TuerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TuerType'):
        if self.ScharnierSeite is not None and 'ScharnierSeite' not in already_processed:
            already_processed.append('ScharnierSeite')
            outfile.write(' ScharnierSeite=%s' % (self.gds_format_string(quote_attrib(self.ScharnierSeite), input_name='ScharnierSeite'), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TuerType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Beschlaege is not None:
            self.Beschlaege.export(outfile, level, namespace_, name_='Beschlaege', pretty_print=pretty_print)
        if self.Front is not None:
            self.Front.export(outfile, level, namespace_, name_='Front', pretty_print=pretty_print)
        for Innenschubkasten_ in self.Innenschubkasten:
            Innenschubkasten_.export(outfile, level, namespace_, name_='Innenschubkasten', pretty_print=pretty_print)
        for Traverse_ in self.Traverse:
            Traverse_.export(outfile, level, namespace_, name_='Traverse', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Beschlaege is not None or
            self.Front is not None or
            self.Innenschubkasten or
            self.Traverse
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TuerType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ScharnierSeite is not None and 'ScharnierSeite' not in already_processed:
            already_processed.append('ScharnierSeite')
            showIndent(outfile, level)
            outfile.write('ScharnierSeite = "%s",\n' % (self.ScharnierSeite,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Beschlaege is not None:
            showIndent(outfile, level)
            outfile.write('Beschlaege=model_.BeschlaegeType(\n')
            self.Beschlaege.exportLiteral(outfile, level, name_='Beschlaege')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Front is not None:
            showIndent(outfile, level)
            outfile.write('Front=model_.FrontType(\n')
            self.Front.exportLiteral(outfile, level, name_='Front')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Innenschubkasten=[\n')
        level += 1
        for Innenschubkasten_ in self.Innenschubkasten:
            showIndent(outfile, level)
            outfile.write('model_.InnenschubkastenType(\n')
            Innenschubkasten_.exportLiteral(outfile, level, name_='InnenschubkastenType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Traverse=[\n')
        level += 1
        for Traverse_ in self.Traverse:
            showIndent(outfile, level)
            outfile.write('model_.TraverseType(\n')
            Traverse_.exportLiteral(outfile, level, name_='TraverseType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ScharnierSeite', node)
        if value is not None and 'ScharnierSeite' not in already_processed:
            already_processed.append('ScharnierSeite')
            self.ScharnierSeite = value
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Beschlaege':
            obj_ = BeschlaegeType.factory()
            obj_.build(child_)
            self.set_Beschlaege(obj_)
        elif nodeName_ == 'Front':
            obj_ = FrontType.factory()
            obj_.build(child_)
            self.set_Front(obj_)
        elif nodeName_ == 'Innenschubkasten':
            obj_ = InnenschubkastenType.factory()
            obj_.build(child_)
            self.Innenschubkasten.append(obj_)
        elif nodeName_ == 'Traverse':
            obj_ = TraverseType.factory()
            obj_.build(child_)
            self.Traverse.append(obj_)
# end class TuerType


class DoppeltuerType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Beschlaege=None, Front=None, Innenschubkasten=None, Mittelwand=None, Steher=None, Traverse=None):
        self.Name = _cast(None, Name)
        self.Beschlaege = Beschlaege
        if Front is None:
            self.Front = []
        else:
            self.Front = Front
        if Innenschubkasten is None:
            self.Innenschubkasten = []
        else:
            self.Innenschubkasten = Innenschubkasten
        if Mittelwand is None:
            self.Mittelwand = []
        else:
            self.Mittelwand = Mittelwand
        self.Steher = Steher
        if Traverse is None:
            self.Traverse = []
        else:
            self.Traverse = Traverse
    def factory(*args_, **kwargs_):
        if DoppeltuerType.subclass:
            return DoppeltuerType.subclass(*args_, **kwargs_)
        else:
            return DoppeltuerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Beschlaege(self): return self.Beschlaege
    def set_Beschlaege(self, Beschlaege): self.Beschlaege = Beschlaege
    def get_Front(self): return self.Front
    def set_Front(self, Front): self.Front = Front
    def add_Front(self, value): self.Front.append(value)
    def insert_Front(self, index, value): self.Front[index] = value
    def get_Innenschubkasten(self): return self.Innenschubkasten
    def set_Innenschubkasten(self, Innenschubkasten): self.Innenschubkasten = Innenschubkasten
    def add_Innenschubkasten(self, value): self.Innenschubkasten.append(value)
    def insert_Innenschubkasten(self, index, value): self.Innenschubkasten[index] = value
    def get_Mittelwand(self): return self.Mittelwand
    def set_Mittelwand(self, Mittelwand): self.Mittelwand = Mittelwand
    def add_Mittelwand(self, value): self.Mittelwand.append(value)
    def insert_Mittelwand(self, index, value): self.Mittelwand[index] = value
    def get_Steher(self): return self.Steher
    def set_Steher(self, Steher): self.Steher = Steher
    def get_Traverse(self): return self.Traverse
    def set_Traverse(self, Traverse): self.Traverse = Traverse
    def add_Traverse(self, value): self.Traverse.append(value)
    def insert_Traverse(self, index, value): self.Traverse[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def export(self, outfile, level, namespace_='', name_='DoppeltuerType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DoppeltuerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DoppeltuerType'):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DoppeltuerType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Beschlaege is not None:
            self.Beschlaege.export(outfile, level, namespace_, name_='Beschlaege', pretty_print=pretty_print)
        for Front_ in self.Front:
            Front_.export(outfile, level, namespace_, name_='Front', pretty_print=pretty_print)
        for Innenschubkasten_ in self.Innenschubkasten:
            Innenschubkasten_.export(outfile, level, namespace_, name_='Innenschubkasten', pretty_print=pretty_print)
        for Mittelwand_ in self.Mittelwand:
            Mittelwand_.export(outfile, level, namespace_, name_='Mittelwand', pretty_print=pretty_print)
        if self.Steher is not None:
            self.Steher.export(outfile, level, namespace_, name_='Steher', pretty_print=pretty_print)
        for Traverse_ in self.Traverse:
            Traverse_.export(outfile, level, namespace_, name_='Traverse', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Beschlaege is not None or
            self.Front or
            self.Innenschubkasten or
            self.Mittelwand or
            self.Steher is not None or
            self.Traverse
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DoppeltuerType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Beschlaege is not None:
            showIndent(outfile, level)
            outfile.write('Beschlaege=model_.BeschlaegeType(\n')
            self.Beschlaege.exportLiteral(outfile, level, name_='Beschlaege')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Front=[\n')
        level += 1
        for Front_ in self.Front:
            showIndent(outfile, level)
            outfile.write('model_.FrontType(\n')
            Front_.exportLiteral(outfile, level, name_='FrontType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Innenschubkasten=[\n')
        level += 1
        for Innenschubkasten_ in self.Innenschubkasten:
            showIndent(outfile, level)
            outfile.write('model_.InnenschubkastenType(\n')
            Innenschubkasten_.exportLiteral(outfile, level, name_='InnenschubkastenType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Mittelwand=[\n')
        level += 1
        for Mittelwand_ in self.Mittelwand:
            showIndent(outfile, level)
            outfile.write('model_.GeometryType(\n')
            Mittelwand_.exportLiteral(outfile, level, name_='GeometryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Steher is not None:
            showIndent(outfile, level)
            outfile.write('Steher=model_.GeometryType(\n')
            self.Steher.exportLiteral(outfile, level, name_='Steher')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Traverse=[\n')
        level += 1
        for Traverse_ in self.Traverse:
            showIndent(outfile, level)
            outfile.write('model_.TraverseType(\n')
            Traverse_.exportLiteral(outfile, level, name_='TraverseType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Beschlaege':
            obj_ = BeschlaegeType.factory()
            obj_.build(child_)
            self.set_Beschlaege(obj_)
        elif nodeName_ == 'Front':
            obj_ = FrontType.factory()
            obj_.build(child_)
            self.Front.append(obj_)
        elif nodeName_ == 'Innenschubkasten':
            obj_ = InnenschubkastenType.factory()
            obj_.build(child_)
            self.Innenschubkasten.append(obj_)
        elif nodeName_ == 'Mittelwand':
            class_obj_ = self.get_class_obj_(child_, GeometryType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Mittelwand.append(obj_)
        elif nodeName_ == 'Steher':
            class_obj_ = self.get_class_obj_(child_, GeometryType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_Steher(obj_)
        elif nodeName_ == 'Traverse':
            obj_ = TraverseType.factory()
            obj_.build(child_)
            self.Traverse.append(obj_)
# end class DoppeltuerType


class BlindfrontType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Front=None):
        self.Name = _cast(None, Name)
        self.Front = Front
    def factory(*args_, **kwargs_):
        if BlindfrontType.subclass:
            return BlindfrontType.subclass(*args_, **kwargs_)
        else:
            return BlindfrontType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Front(self): return self.Front
    def set_Front(self, Front): self.Front = Front
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def export(self, outfile, level, namespace_='', name_='BlindfrontType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BlindfrontType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BlindfrontType'):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BlindfrontType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Front is not None:
            self.Front.export(outfile, level, namespace_, name_='Front', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Front is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BlindfrontType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Front is not None:
            showIndent(outfile, level)
            outfile.write('Front=model_.FrontType(\n')
            self.Front.exportLiteral(outfile, level, name_='Front')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Front':
            obj_ = FrontType.factory()
            obj_.build(child_)
            self.set_Front(obj_)
# end class BlindfrontType


class AussenschubkastenType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Schubkastenart=None, Auszugslaenge=None, Name=None, Beschlaege=None, Front=None, Holzschubkasten=None, GlasBoxside=None, Eckblende=None, Verbindungsstueck=None, Boden=None, Rueckwand=None, EINSCHUBELEMENT_BCO=None, EINSCHUBELEMENT_antaro=None, Innenschubkasten=None, Zwischenstueck=None):
        self.Schubkastenart = _cast(None, Schubkastenart)
        self.Auszugslaenge = _cast(float, Auszugslaenge)
        self.Name = _cast(None, Name)
        self.Beschlaege = Beschlaege
        if Front is None:
            self.Front = []
        else:
            self.Front = Front
        self.Holzschubkasten = Holzschubkasten
        if GlasBoxside is None:
            self.GlasBoxside = []
        else:
            self.GlasBoxside = GlasBoxside
        self.Eckblende = Eckblende
        if Verbindungsstueck is None:
            self.Verbindungsstueck = []
        else:
            self.Verbindungsstueck = Verbindungsstueck
        if Boden is None:
            self.Boden = []
        else:
            self.Boden = Boden
        if Rueckwand is None:
            self.Rueckwand = []
        else:
            self.Rueckwand = Rueckwand
        if EINSCHUBELEMENT_BCO is None:
            self.EINSCHUBELEMENT_BCO = []
        else:
            self.EINSCHUBELEMENT_BCO = EINSCHUBELEMENT_BCO
        if EINSCHUBELEMENT_antaro is None:
            self.EINSCHUBELEMENT_antaro = []
        else:
            self.EINSCHUBELEMENT_antaro = EINSCHUBELEMENT_antaro
        if Innenschubkasten is None:
            self.Innenschubkasten = []
        else:
            self.Innenschubkasten = Innenschubkasten
        self.Zwischenstueck = Zwischenstueck
    def factory(*args_, **kwargs_):
        if AussenschubkastenType.subclass:
            return AussenschubkastenType.subclass(*args_, **kwargs_)
        else:
            return AussenschubkastenType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Beschlaege(self): return self.Beschlaege
    def set_Beschlaege(self, Beschlaege): self.Beschlaege = Beschlaege
    def get_Front(self): return self.Front
    def set_Front(self, Front): self.Front = Front
    def add_Front(self, value): self.Front.append(value)
    def insert_Front(self, index, value): self.Front[index] = value
    def get_Holzschubkasten(self): return self.Holzschubkasten
    def set_Holzschubkasten(self, Holzschubkasten): self.Holzschubkasten = Holzschubkasten
    def get_GlasBoxside(self): return self.GlasBoxside
    def set_GlasBoxside(self, GlasBoxside): self.GlasBoxside = GlasBoxside
    def add_GlasBoxside(self, value): self.GlasBoxside.append(value)
    def insert_GlasBoxside(self, index, value): self.GlasBoxside[index] = value
    def get_Eckblende(self): return self.Eckblende
    def set_Eckblende(self, Eckblende): self.Eckblende = Eckblende
    def get_Verbindungsstueck(self): return self.Verbindungsstueck
    def set_Verbindungsstueck(self, Verbindungsstueck): self.Verbindungsstueck = Verbindungsstueck
    def add_Verbindungsstueck(self, value): self.Verbindungsstueck.append(value)
    def insert_Verbindungsstueck(self, index, value): self.Verbindungsstueck[index] = value
    def get_Boden(self): return self.Boden
    def set_Boden(self, Boden): self.Boden = Boden
    def add_Boden(self, value): self.Boden.append(value)
    def insert_Boden(self, index, value): self.Boden[index] = value
    def get_Rueckwand(self): return self.Rueckwand
    def set_Rueckwand(self, Rueckwand): self.Rueckwand = Rueckwand
    def add_Rueckwand(self, value): self.Rueckwand.append(value)
    def insert_Rueckwand(self, index, value): self.Rueckwand[index] = value
    def get_EINSCHUBELEMENT_BCO(self): return self.EINSCHUBELEMENT_BCO
    def set_EINSCHUBELEMENT_BCO(self, EINSCHUBELEMENT_BCO): self.EINSCHUBELEMENT_BCO = EINSCHUBELEMENT_BCO
    def add_EINSCHUBELEMENT_BCO(self, value): self.EINSCHUBELEMENT_BCO.append(value)
    def insert_EINSCHUBELEMENT_BCO(self, index, value): self.EINSCHUBELEMENT_BCO[index] = value
    def get_EINSCHUBELEMENT_antaro(self): return self.EINSCHUBELEMENT_antaro
    def set_EINSCHUBELEMENT_antaro(self, EINSCHUBELEMENT_antaro): self.EINSCHUBELEMENT_antaro = EINSCHUBELEMENT_antaro
    def add_EINSCHUBELEMENT_antaro(self, value): self.EINSCHUBELEMENT_antaro.append(value)
    def insert_EINSCHUBELEMENT_antaro(self, index, value): self.EINSCHUBELEMENT_antaro[index] = value
    def get_Innenschubkasten(self): return self.Innenschubkasten
    def set_Innenschubkasten(self, Innenschubkasten): self.Innenschubkasten = Innenschubkasten
    def add_Innenschubkasten(self, value): self.Innenschubkasten.append(value)
    def insert_Innenschubkasten(self, index, value): self.Innenschubkasten[index] = value
    def get_Zwischenstueck(self): return self.Zwischenstueck
    def set_Zwischenstueck(self, Zwischenstueck): self.Zwischenstueck = Zwischenstueck
    def get_Schubkastenart(self): return self.Schubkastenart
    def set_Schubkastenart(self, Schubkastenart): self.Schubkastenart = Schubkastenart
    def get_Auszugslaenge(self): return self.Auszugslaenge
    def set_Auszugslaenge(self, Auszugslaenge): self.Auszugslaenge = Auszugslaenge
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def export(self, outfile, level, namespace_='', name_='AussenschubkastenType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AussenschubkastenType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
            self.GroupChildObjectK3() # For K3Mebel add
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AussenschubkastenType'):
        if self.Schubkastenart is not None and 'Schubkastenart' not in already_processed:
            already_processed.append('Schubkastenart')
            outfile.write(' Schubkastenart=%s' % (self.gds_format_string(quote_attrib(self.Schubkastenart), input_name='Schubkastenart'), ))
        if self.Auszugslaenge is not None and 'Auszugslaenge' not in already_processed:
            already_processed.append('Auszugslaenge')
            outfile.write(' Auszugslaenge="%s"' % self.gds_format_float(self.Auszugslaenge, input_name='Auszugslaenge'))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AussenschubkastenType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Beschlaege is not None:
            self.Beschlaege.export(outfile, level, namespace_, name_='Beschlaege', pretty_print=pretty_print)
        for Front_ in self.Front:
            Front_.export(outfile, level, namespace_, name_='Front', pretty_print=pretty_print)
        if self.Holzschubkasten is not None:
            self.Holzschubkasten.export(outfile, level, namespace_, name_='Holzschubkasten', pretty_print=pretty_print)
        for GlasBoxside_ in self.GlasBoxside:
            GlasBoxside_.export(outfile, level, namespace_, name_='GlasBoxside', pretty_print=pretty_print)
        if self.Eckblende is not None:
            self.Eckblende.export(outfile, level, namespace_, name_='Eckblende', pretty_print=pretty_print)
        for Verbindungsstueck_ in self.Verbindungsstueck:
            Verbindungsstueck_.export(outfile, level, namespace_, name_='Verbindungsstueck', pretty_print=pretty_print)
        for Boden_ in self.Boden:
            Boden_.export(outfile, level, namespace_, name_='Boden', pretty_print=pretty_print)
        for Rueckwand_ in self.Rueckwand:
            Rueckwand_.export(outfile, level, namespace_, name_='Rueckwand', pretty_print=pretty_print)
        for EINSCHUBELEMENT_BCO_ in self.EINSCHUBELEMENT_BCO:
            EINSCHUBELEMENT_BCO_.export(outfile, level, namespace_, name_='EINSCHUBELEMENT_BCO', pretty_print=pretty_print)
        for EINSCHUBELEMENT_antaro_ in self.EINSCHUBELEMENT_antaro:
            EINSCHUBELEMENT_antaro_.export(outfile, level, namespace_, name_='EINSCHUBELEMENT_antaro', pretty_print=pretty_print)
        for Innenschubkasten_ in self.Innenschubkasten:
            Innenschubkasten_.export(outfile, level, namespace_, name_='Innenschubkasten', pretty_print=pretty_print)
        if self.Zwischenstueck is not None:
            self.Zwischenstueck.export(outfile, level, namespace_, name_='Zwischenstueck', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Beschlaege is not None or
            self.Front or
            self.Holzschubkasten is not None or
            self.GlasBoxside or
            self.Eckblende is not None or
            self.Verbindungsstueck or
            self.Boden or
            self.Rueckwand or
            self.EINSCHUBELEMENT_BCO or
            self.EINSCHUBELEMENT_antaro or
            self.Innenschubkasten or
            self.Zwischenstueck is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AussenschubkastenType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Schubkastenart is not None and 'Schubkastenart' not in already_processed:
            already_processed.append('Schubkastenart')
            showIndent(outfile, level)
            outfile.write('Schubkastenart = "%s",\n' % (self.Schubkastenart,))
        if self.Auszugslaenge is not None and 'Auszugslaenge' not in already_processed:
            already_processed.append('Auszugslaenge')
            showIndent(outfile, level)
            outfile.write('Auszugslaenge = %e,\n' % (self.Auszugslaenge,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Beschlaege is not None:
            showIndent(outfile, level)
            outfile.write('Beschlaege=model_.BeschlaegeType(\n')
            self.Beschlaege.exportLiteral(outfile, level, name_='Beschlaege')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Front=[\n')
        level += 1
        for Front_ in self.Front:
            showIndent(outfile, level)
            outfile.write('model_.FrontType(\n')
            Front_.exportLiteral(outfile, level, name_='FrontType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Holzschubkasten is not None:
            showIndent(outfile, level)
            outfile.write('Holzschubkasten=model_.HolzschubkastenType(\n')
            self.Holzschubkasten.exportLiteral(outfile, level, name_='Holzschubkasten')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('GlasBoxside=[\n')
        level += 1
        for GlasBoxside_ in self.GlasBoxside:
            showIndent(outfile, level)
            outfile.write('model_.GeometryType(\n')
            GlasBoxside_.exportLiteral(outfile, level, name_='GeometryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Eckblende is not None:
            showIndent(outfile, level)
            outfile.write('Eckblende=model_.GeometryType(\n')
            self.Eckblende.exportLiteral(outfile, level, name_='Eckblende')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Verbindungsstueck=[\n')
        level += 1
        for Verbindungsstueck_ in self.Verbindungsstueck:
            showIndent(outfile, level)
            outfile.write('model_.GeometryType(\n')
            Verbindungsstueck_.exportLiteral(outfile, level, name_='GeometryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Boden=[\n')
        level += 1
        for Boden_ in self.Boden:
            showIndent(outfile, level)
            outfile.write('model_.GeometryType(\n')
            Boden_.exportLiteral(outfile, level, name_='GeometryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Rueckwand=[\n')
        level += 1
        for Rueckwand_ in self.Rueckwand:
            showIndent(outfile, level)
            outfile.write('model_.GeometryType(\n')
            Rueckwand_.exportLiteral(outfile, level, name_='GeometryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('EINSCHUBELEMENT_BCO=[\n')
        level += 1
        for EINSCHUBELEMENT_BCO_ in self.EINSCHUBELEMENT_BCO:
            showIndent(outfile, level)
            outfile.write('model_.GeometryType(\n')
            EINSCHUBELEMENT_BCO_.exportLiteral(outfile, level, name_='GeometryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('EINSCHUBELEMENT_antaro=[\n')
        level += 1
        for EINSCHUBELEMENT_antaro_ in self.EINSCHUBELEMENT_antaro:
            showIndent(outfile, level)
            outfile.write('model_.GeometryType(\n')
            EINSCHUBELEMENT_antaro_.exportLiteral(outfile, level, name_='GeometryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Innenschubkasten=[\n')
        level += 1
        for Innenschubkasten_ in self.Innenschubkasten:
            showIndent(outfile, level)
            outfile.write('model_.InnenschubkastenType(\n')
            Innenschubkasten_.exportLiteral(outfile, level, name_='InnenschubkastenType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Zwischenstueck is not None:
            showIndent(outfile, level)
            outfile.write('Zwischenstueck=model_.GeometryType(\n')
            self.Zwischenstueck.exportLiteral(outfile, level, name_='Zwischenstueck')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Schubkastenart', node)
        if value is not None and 'Schubkastenart' not in already_processed:
            already_processed.append('Schubkastenart')
            self.Schubkastenart = value
        value = find_attr_value_('Auszugslaenge', node)
        if value is not None and 'Auszugslaenge' not in already_processed:
            already_processed.append('Auszugslaenge')
            try:
                self.Auszugslaenge = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Auszugslaenge): %s' % exp)
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Beschlaege':
            obj_ = BeschlaegeType.factory()
            obj_.build(child_)
            self.set_Beschlaege(obj_)
        elif nodeName_ == 'Front':
            obj_ = FrontType.factory()
            obj_.build(child_)
            self.Front.append(obj_)
        elif nodeName_ == 'Holzschubkasten':
            obj_ = HolzschubkastenType.factory()
            obj_.build(child_)
            self.set_Holzschubkasten(obj_)
        elif nodeName_ == 'GlasBoxside':
            class_obj_ = self.get_class_obj_(child_, GeometryType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.GlasBoxside.append(obj_)
        elif nodeName_ == 'Eckblende':
            class_obj_ = self.get_class_obj_(child_, GeometryType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_Eckblende(obj_)
        elif nodeName_ == 'Verbindungsstueck':
            class_obj_ = self.get_class_obj_(child_, GeometryType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Verbindungsstueck.append(obj_)
        elif nodeName_ == 'Boden':
            class_obj_ = self.get_class_obj_(child_, GeometryType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Boden.append(obj_)
        elif nodeName_ == 'Rueckwand':
            class_obj_ = self.get_class_obj_(child_, GeometryType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Rueckwand.append(obj_)
        elif nodeName_ == 'EINSCHUBELEMENT_BCO':
            class_obj_ = self.get_class_obj_(child_, GeometryType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.EINSCHUBELEMENT_BCO.append(obj_)
        elif nodeName_ == 'EINSCHUBELEMENT_antaro':
            class_obj_ = self.get_class_obj_(child_, GeometryType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.EINSCHUBELEMENT_antaro.append(obj_)
        elif nodeName_ == 'Innenschubkasten':
            obj_ = InnenschubkastenType.factory()
            obj_.build(child_)
            self.Innenschubkasten.append(obj_)
        elif nodeName_ == 'Zwischenstueck':
            class_obj_ = self.get_class_obj_(child_, GeometryType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_Zwischenstueck(obj_)
# end class AussenschubkastenType


class InnenschubkastenType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Schubkastenart=None, Auszugslaenge=None, Name=None, Beschlaege=None, Front=None, Holzschubkasten=None, Boden=None, Rueckwand=None, EINSCHUBELEMENT_BCO=None, EINSCHUBELEMENT_FRONT=None, EINSCHUBELEMENT_antaro=None, SeitlicheDistanz=None):
        self.Schubkastenart = _cast(None, Schubkastenart)
        self.Auszugslaenge = _cast(float, Auszugslaenge)
        self.Name = _cast(None, Name)
        self.Beschlaege = Beschlaege
        self.Front = Front
        self.Holzschubkasten = Holzschubkasten
        self.Boden = Boden
        self.Rueckwand = Rueckwand
        if EINSCHUBELEMENT_BCO is None:
            self.EINSCHUBELEMENT_BCO = []
        else:
            self.EINSCHUBELEMENT_BCO = EINSCHUBELEMENT_BCO
        self.EINSCHUBELEMENT_FRONT = EINSCHUBELEMENT_FRONT
        if EINSCHUBELEMENT_antaro is None:
            self.EINSCHUBELEMENT_antaro = []
        else:
            self.EINSCHUBELEMENT_antaro = EINSCHUBELEMENT_antaro
        if SeitlicheDistanz is None:
            self.SeitlicheDistanz = []
        else:
            self.SeitlicheDistanz = SeitlicheDistanz
    def factory(*args_, **kwargs_):
        if InnenschubkastenType.subclass:
            return InnenschubkastenType.subclass(*args_, **kwargs_)
        else:
            return InnenschubkastenType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Beschlaege(self): return self.Beschlaege
    def set_Beschlaege(self, Beschlaege): self.Beschlaege = Beschlaege
    def get_Front(self): return self.Front
    def set_Front(self, Front): self.Front = Front
    def get_Holzschubkasten(self): return self.Holzschubkasten
    def set_Holzschubkasten(self, Holzschubkasten): self.Holzschubkasten = Holzschubkasten
    def get_Boden(self): return self.Boden
    def set_Boden(self, Boden): self.Boden = Boden
    def get_Rueckwand(self): return self.Rueckwand
    def set_Rueckwand(self, Rueckwand): self.Rueckwand = Rueckwand
    def get_EINSCHUBELEMENT_BCO(self): return self.EINSCHUBELEMENT_BCO
    def set_EINSCHUBELEMENT_BCO(self, EINSCHUBELEMENT_BCO): self.EINSCHUBELEMENT_BCO = EINSCHUBELEMENT_BCO
    def add_EINSCHUBELEMENT_BCO(self, value): self.EINSCHUBELEMENT_BCO.append(value)
    def insert_EINSCHUBELEMENT_BCO(self, index, value): self.EINSCHUBELEMENT_BCO[index] = value
    def get_EINSCHUBELEMENT_FRONT(self): return self.EINSCHUBELEMENT_FRONT
    def set_EINSCHUBELEMENT_FRONT(self, EINSCHUBELEMENT_FRONT): self.EINSCHUBELEMENT_FRONT = EINSCHUBELEMENT_FRONT
    def get_EINSCHUBELEMENT_antaro(self): return self.EINSCHUBELEMENT_antaro
    def set_EINSCHUBELEMENT_antaro(self, EINSCHUBELEMENT_antaro): self.EINSCHUBELEMENT_antaro = EINSCHUBELEMENT_antaro
    def add_EINSCHUBELEMENT_antaro(self, value): self.EINSCHUBELEMENT_antaro.append(value)
    def insert_EINSCHUBELEMENT_antaro(self, index, value): self.EINSCHUBELEMENT_antaro[index] = value
    def get_SeitlicheDistanz(self): return self.SeitlicheDistanz
    def set_SeitlicheDistanz(self, SeitlicheDistanz): self.SeitlicheDistanz = SeitlicheDistanz
    def add_SeitlicheDistanz(self, value): self.SeitlicheDistanz.append(value)
    def insert_SeitlicheDistanz(self, index, value): self.SeitlicheDistanz[index] = value
    def get_Schubkastenart(self): return self.Schubkastenart
    def set_Schubkastenart(self, Schubkastenart): self.Schubkastenart = Schubkastenart
    def get_Auszugslaenge(self): return self.Auszugslaenge
    def set_Auszugslaenge(self, Auszugslaenge): self.Auszugslaenge = Auszugslaenge
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def export(self, outfile, level, namespace_='', name_='InnenschubkastenType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InnenschubkastenType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InnenschubkastenType'):
        if self.Schubkastenart is not None and 'Schubkastenart' not in already_processed:
            already_processed.append('Schubkastenart')
            outfile.write(' Schubkastenart=%s' % (self.gds_format_string(quote_attrib(self.Schubkastenart), input_name='Schubkastenart'), ))
        if self.Auszugslaenge is not None and 'Auszugslaenge' not in already_processed:
            already_processed.append('Auszugslaenge')
            outfile.write(' Auszugslaenge="%s"' % self.gds_format_float(self.Auszugslaenge, input_name='Auszugslaenge'))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='InnenschubkastenType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Beschlaege is not None:
            self.Beschlaege.export(outfile, level, namespace_, name_='Beschlaege', pretty_print=pretty_print)
        if self.Front is not None:
            self.Front.export(outfile, level, namespace_, name_='Front', pretty_print=pretty_print)
        if self.Holzschubkasten is not None:
            self.Holzschubkasten.export(outfile, level, namespace_, name_='Holzschubkasten', pretty_print=pretty_print)
        if self.Boden is not None:
            self.Boden.export(outfile, level, namespace_, name_='Boden', pretty_print=pretty_print)
        if self.Rueckwand is not None:
            self.Rueckwand.export(outfile, level, namespace_, name_='Rueckwand', pretty_print=pretty_print)
        for EINSCHUBELEMENT_BCO_ in self.EINSCHUBELEMENT_BCO:
            EINSCHUBELEMENT_BCO_.export(outfile, level, namespace_, name_='EINSCHUBELEMENT_BCO', pretty_print=pretty_print)
        if self.EINSCHUBELEMENT_FRONT is not None:
            self.EINSCHUBELEMENT_FRONT.export(outfile, level, namespace_, name_='EINSCHUBELEMENT_FRONT', pretty_print=pretty_print)
        for EINSCHUBELEMENT_antaro_ in self.EINSCHUBELEMENT_antaro:
            EINSCHUBELEMENT_antaro_.export(outfile, level, namespace_, name_='EINSCHUBELEMENT_antaro', pretty_print=pretty_print)
        for SeitlicheDistanz_ in self.SeitlicheDistanz:
            SeitlicheDistanz_.export(outfile, level, namespace_, name_='SeitlicheDistanz', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Beschlaege is not None or
            self.Front is not None or
            self.Holzschubkasten is not None or
            self.Boden is not None or
            self.Rueckwand is not None or
            self.EINSCHUBELEMENT_BCO or
            self.EINSCHUBELEMENT_FRONT is not None or
            self.EINSCHUBELEMENT_antaro or
            self.SeitlicheDistanz
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='InnenschubkastenType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Schubkastenart is not None and 'Schubkastenart' not in already_processed:
            already_processed.append('Schubkastenart')
            showIndent(outfile, level)
            outfile.write('Schubkastenart = "%s",\n' % (self.Schubkastenart,))
        if self.Auszugslaenge is not None and 'Auszugslaenge' not in already_processed:
            already_processed.append('Auszugslaenge')
            showIndent(outfile, level)
            outfile.write('Auszugslaenge = %e,\n' % (self.Auszugslaenge,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Beschlaege is not None:
            showIndent(outfile, level)
            outfile.write('Beschlaege=model_.BeschlaegeType(\n')
            self.Beschlaege.exportLiteral(outfile, level, name_='Beschlaege')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Front is not None:
            showIndent(outfile, level)
            outfile.write('Front=model_.FrontType(\n')
            self.Front.exportLiteral(outfile, level, name_='Front')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Holzschubkasten is not None:
            showIndent(outfile, level)
            outfile.write('Holzschubkasten=model_.HolzschubkastenType(\n')
            self.Holzschubkasten.exportLiteral(outfile, level, name_='Holzschubkasten')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Boden is not None:
            showIndent(outfile, level)
            outfile.write('Boden=model_.GeometryType(\n')
            self.Boden.exportLiteral(outfile, level, name_='Boden')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Rueckwand is not None:
            showIndent(outfile, level)
            outfile.write('Rueckwand=model_.GeometryType(\n')
            self.Rueckwand.exportLiteral(outfile, level, name_='Rueckwand')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('EINSCHUBELEMENT_BCO=[\n')
        level += 1
        for EINSCHUBELEMENT_BCO_ in self.EINSCHUBELEMENT_BCO:
            showIndent(outfile, level)
            outfile.write('model_.GeometryType(\n')
            EINSCHUBELEMENT_BCO_.exportLiteral(outfile, level, name_='GeometryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.EINSCHUBELEMENT_FRONT is not None:
            showIndent(outfile, level)
            outfile.write('EINSCHUBELEMENT_FRONT=model_.GeometryType(\n')
            self.EINSCHUBELEMENT_FRONT.exportLiteral(outfile, level, name_='EINSCHUBELEMENT_FRONT')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('EINSCHUBELEMENT_antaro=[\n')
        level += 1
        for EINSCHUBELEMENT_antaro_ in self.EINSCHUBELEMENT_antaro:
            showIndent(outfile, level)
            outfile.write('model_.GeometryType(\n')
            EINSCHUBELEMENT_antaro_.exportLiteral(outfile, level, name_='GeometryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SeitlicheDistanz=[\n')
        level += 1
        for SeitlicheDistanz_ in self.SeitlicheDistanz:
            showIndent(outfile, level)
            outfile.write('model_.GeometryType(\n')
            SeitlicheDistanz_.exportLiteral(outfile, level, name_='GeometryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Schubkastenart', node)
        if value is not None and 'Schubkastenart' not in already_processed:
            already_processed.append('Schubkastenart')
            self.Schubkastenart = value
        value = find_attr_value_('Auszugslaenge', node)
        if value is not None and 'Auszugslaenge' not in already_processed:
            already_processed.append('Auszugslaenge')
            try:
                self.Auszugslaenge = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Auszugslaenge): %s' % exp)
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Beschlaege':
            obj_ = BeschlaegeType.factory()
            obj_.build(child_)
            self.set_Beschlaege(obj_)
        elif nodeName_ == 'Front':
            obj_ = FrontType.factory()
            obj_.build(child_)
            self.set_Front(obj_)
        elif nodeName_ == 'Holzschubkasten':
            obj_ = HolzschubkastenType.factory()
            obj_.build(child_)
            self.set_Holzschubkasten(obj_)
        elif nodeName_ == 'Boden':
            class_obj_ = self.get_class_obj_(child_, GeometryType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_Boden(obj_)
        elif nodeName_ == 'Rueckwand':
            class_obj_ = self.get_class_obj_(child_, GeometryType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_Rueckwand(obj_)
        elif nodeName_ == 'EINSCHUBELEMENT_BCO':
            class_obj_ = self.get_class_obj_(child_, GeometryType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.EINSCHUBELEMENT_BCO.append(obj_)
        elif nodeName_ == 'EINSCHUBELEMENT_FRONT':
            class_obj_ = self.get_class_obj_(child_, GeometryType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_EINSCHUBELEMENT_FRONT(obj_)
        elif nodeName_ == 'EINSCHUBELEMENT_antaro':
            class_obj_ = self.get_class_obj_(child_, GeometryType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.EINSCHUBELEMENT_antaro.append(obj_)
        elif nodeName_ == 'SeitlicheDistanz':
            class_obj_ = self.get_class_obj_(child_, GeometryType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.SeitlicheDistanz.append(obj_)
# end class InnenschubkastenType


class TraverseType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Boden=None):
        self.Name = _cast(None, Name)
        self.Boden = Boden
    def factory(*args_, **kwargs_):
        if TraverseType.subclass:
            return TraverseType.subclass(*args_, **kwargs_)
        else:
            return TraverseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Boden(self): return self.Boden
    def set_Boden(self, Boden): self.Boden = Boden
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def export(self, outfile, level, namespace_='', name_='TraverseType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TraverseType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TraverseType'):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TraverseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Boden is not None:
            self.Boden.export(outfile, level, namespace_, name_='Boden', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Boden is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TraverseType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Boden is not None:
            showIndent(outfile, level)
            outfile.write('Boden=model_.GeometryType(\n')
            self.Boden.exportLiteral(outfile, level, name_='Boden')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Boden':
            class_obj_ = self.get_class_obj_(child_, GeometryType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_Boden(obj_)
# end class TraverseType


class KlappensystemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Typ=None, Name=None, Beschlaege=None, Front=None, Mittelwand=None, Steher=None):
        self.Typ = _cast(None, Typ)
        self.Name = _cast(None, Name)
        self.Beschlaege = Beschlaege
        if Front is None:
            self.Front = []
        else:
            self.Front = Front
        self.Mittelwand = Mittelwand
        self.Steher = Steher
    def factory(*args_, **kwargs_):
        if KlappensystemType.subclass:
            return KlappensystemType.subclass(*args_, **kwargs_)
        else:
            return KlappensystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Beschlaege(self): return self.Beschlaege
    def set_Beschlaege(self, Beschlaege): self.Beschlaege = Beschlaege
    def get_Front(self): return self.Front
    def set_Front(self, Front): self.Front = Front
    def add_Front(self, value): self.Front.append(value)
    def insert_Front(self, index, value): self.Front[index] = value
    def get_Mittelwand(self): return self.Mittelwand
    def set_Mittelwand(self, Mittelwand): self.Mittelwand = Mittelwand
    def get_Steher(self): return self.Steher
    def set_Steher(self, Steher): self.Steher = Steher
    def get_Typ(self): return self.Typ
    def set_Typ(self, Typ): self.Typ = Typ
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def export(self, outfile, level, namespace_='', name_='KlappensystemType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KlappensystemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='KlappensystemType'):
        if self.Typ is not None and 'Typ' not in already_processed:
            already_processed.append('Typ')
            outfile.write(' Typ=%s' % (self.gds_format_string(quote_attrib(self.Typ), input_name='Typ'), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='KlappensystemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Beschlaege is not None:
            self.Beschlaege.export(outfile, level, namespace_, name_='Beschlaege', pretty_print=pretty_print)
        for Front_ in self.Front:
            Front_.export(outfile, level, namespace_, name_='Front', pretty_print=pretty_print)
        if self.Mittelwand is not None:
            self.Mittelwand.export(outfile, level, namespace_, name_='Mittelwand', pretty_print=pretty_print)
        if self.Steher is not None:
            self.Steher.export(outfile, level, namespace_, name_='Steher', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Beschlaege is not None or
            self.Front or
            self.Mittelwand is not None or
            self.Steher is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='KlappensystemType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Typ is not None and 'Typ' not in already_processed:
            already_processed.append('Typ')
            showIndent(outfile, level)
            outfile.write('Typ = "%s",\n' % (self.Typ,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Beschlaege is not None:
            showIndent(outfile, level)
            outfile.write('Beschlaege=model_.BeschlaegeType(\n')
            self.Beschlaege.exportLiteral(outfile, level, name_='Beschlaege')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Front=[\n')
        level += 1
        for Front_ in self.Front:
            showIndent(outfile, level)
            outfile.write('model_.FrontType(\n')
            Front_.exportLiteral(outfile, level, name_='FrontType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Mittelwand is not None:
            showIndent(outfile, level)
            outfile.write('Mittelwand=model_.GeometryType(\n')
            self.Mittelwand.exportLiteral(outfile, level, name_='Mittelwand')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Steher is not None:
            showIndent(outfile, level)
            outfile.write('Steher=model_.GeometryType(\n')
            self.Steher.exportLiteral(outfile, level, name_='Steher')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Typ', node)
        if value is not None and 'Typ' not in already_processed:
            already_processed.append('Typ')
            self.Typ = value
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Beschlaege':
            obj_ = BeschlaegeType.factory()
            obj_.build(child_)
            self.set_Beschlaege(obj_)
        elif nodeName_ == 'Front':
            obj_ = FrontType.factory()
            obj_.build(child_)
            self.Front.append(obj_)
        elif nodeName_ == 'Mittelwand':
            class_obj_ = self.get_class_obj_(child_, GeometryType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_Mittelwand(obj_)
        elif nodeName_ == 'Steher':
            class_obj_ = self.get_class_obj_(child_, GeometryType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_Steher(obj_)
# end class KlappensystemType


class VorratsauszugType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Beschlaege=None, Front=None, Aussenschubkasten=None):
        self.Name = _cast(None, Name)
        self.Beschlaege = Beschlaege
        self.Front = Front
        if Aussenschubkasten is None:
            self.Aussenschubkasten = []
        else:
            self.Aussenschubkasten = Aussenschubkasten
    def factory(*args_, **kwargs_):
        if VorratsauszugType.subclass:
            return VorratsauszugType.subclass(*args_, **kwargs_)
        else:
            return VorratsauszugType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Beschlaege(self): return self.Beschlaege
    def set_Beschlaege(self, Beschlaege): self.Beschlaege = Beschlaege
    def get_Front(self): return self.Front
    def set_Front(self, Front): self.Front = Front
    def get_Aussenschubkasten(self): return self.Aussenschubkasten
    def set_Aussenschubkasten(self, Aussenschubkasten): self.Aussenschubkasten = Aussenschubkasten
    def add_Aussenschubkasten(self, value): self.Aussenschubkasten.append(value)
    def insert_Aussenschubkasten(self, index, value): self.Aussenschubkasten[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def export(self, outfile, level, namespace_='', name_='VorratsauszugType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VorratsauszugType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VorratsauszugType'):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='VorratsauszugType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Beschlaege is not None:
            self.Beschlaege.export(outfile, level, namespace_, name_='Beschlaege', pretty_print=pretty_print)
        if self.Front is not None:
            self.Front.export(outfile, level, namespace_, name_='Front', pretty_print=pretty_print)
        for Aussenschubkasten_ in self.Aussenschubkasten:
            Aussenschubkasten_.export(outfile, level, namespace_, name_='Aussenschubkasten', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Beschlaege is not None or
            self.Front is not None or
            self.Aussenschubkasten
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VorratsauszugType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Beschlaege is not None:
            showIndent(outfile, level)
            outfile.write('Beschlaege=model_.BeschlaegeType(\n')
            self.Beschlaege.exportLiteral(outfile, level, name_='Beschlaege')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Front is not None:
            showIndent(outfile, level)
            outfile.write('Front=model_.FrontType(\n')
            self.Front.exportLiteral(outfile, level, name_='Front')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Aussenschubkasten=[\n')
        level += 1
        for Aussenschubkasten_ in self.Aussenschubkasten:
            showIndent(outfile, level)
            outfile.write('model_.AussenschubkastenType(\n')
            Aussenschubkasten_.exportLiteral(outfile, level, name_='AussenschubkastenType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Beschlaege':
            obj_ = BeschlaegeType.factory()
            obj_.build(child_)
            self.set_Beschlaege(obj_)
        elif nodeName_ == 'Front':
            obj_ = FrontType.factory()
            obj_.build(child_)
            self.set_Front(obj_)
        elif nodeName_ == 'Aussenschubkasten':
            obj_ = AussenschubkastenType.factory()
            obj_.build(child_)
            self.Aussenschubkasten.append(obj_)
# end class VorratsauszugType


class BeschlaegeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PositionZ=None, PositionX=None, PositionY=None, Name=None, Bezug=None, WinkelY=None, WinkelX=None, WinkelZ=None, Artikel=None):
        self.PositionZ = _cast(float, PositionZ)
        self.PositionX = _cast(float, PositionX)
        self.PositionY = _cast(float, PositionY)
        self.Name = _cast(None, Name)
        self.Bezug = _cast(None, Bezug)
        self.WinkelY = _cast(float, WinkelY)
        self.WinkelX = _cast(float, WinkelX)
        self.WinkelZ = _cast(float, WinkelZ)
        if Artikel is None:
            self.Artikel = []
        else:
            self.Artikel = Artikel
    def factory(*args_, **kwargs_):
        if BeschlaegeType.subclass:
            return BeschlaegeType.subclass(*args_, **kwargs_)
        else:
            return BeschlaegeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Artikel(self): return self.Artikel
    def set_Artikel(self, Artikel): self.Artikel = Artikel
    def add_Artikel(self, value): self.Artikel.append(value)
    def insert_Artikel(self, index, value): self.Artikel[index] = value
    def get_PositionZ(self): return self.PositionZ
    def set_PositionZ(self, PositionZ): self.PositionZ = PositionZ
    def get_PositionX(self): return self.PositionX
    def set_PositionX(self, PositionX): self.PositionX = PositionX
    def get_PositionY(self): return self.PositionY
    def set_PositionY(self, PositionY): self.PositionY = PositionY
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Bezug(self): return self.Bezug
    def set_Bezug(self, Bezug): self.Bezug = Bezug
    def get_WinkelY(self): return self.WinkelY
    def set_WinkelY(self, WinkelY): self.WinkelY = WinkelY
    def get_WinkelX(self): return self.WinkelX
    def set_WinkelX(self, WinkelX): self.WinkelX = WinkelX
    def get_WinkelZ(self): return self.WinkelZ
    def set_WinkelZ(self, WinkelZ): self.WinkelZ = WinkelZ
    def export(self, outfile, level, namespace_='', name_='BeschlaegeType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BeschlaegeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
            self.GroupChildObjectK3() # For K3Mebel add
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BeschlaegeType'):
        if self.PositionZ is not None and 'PositionZ' not in already_processed:
            already_processed.append('PositionZ')
            outfile.write(' PositionZ="%s"' % self.gds_format_float(self.PositionZ, input_name='PositionZ'))
        if self.PositionX is not None and 'PositionX' not in already_processed:
            already_processed.append('PositionX')
            outfile.write(' PositionX="%s"' % self.gds_format_float(self.PositionX, input_name='PositionX'))
        if self.PositionY is not None and 'PositionY' not in already_processed:
            already_processed.append('PositionY')
            outfile.write(' PositionY="%s"' % self.gds_format_float(self.PositionY, input_name='PositionY'))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name), input_name='Name'), ))
        if self.Bezug is not None and 'Bezug' not in already_processed:
            already_processed.append('Bezug')
            outfile.write(' Bezug=%s' % (self.gds_format_string(quote_attrib(self.Bezug), input_name='Bezug'), ))
        if self.WinkelY is not None and 'WinkelY' not in already_processed:
            already_processed.append('WinkelY')
            outfile.write(' WinkelY="%s"' % self.gds_format_float(self.WinkelY, input_name='WinkelY'))
        if self.WinkelX is not None and 'WinkelX' not in already_processed:
            already_processed.append('WinkelX')
            outfile.write(' WinkelX="%s"' % self.gds_format_float(self.WinkelX, input_name='WinkelX'))
        if self.WinkelZ is not None and 'WinkelZ' not in already_processed:
            already_processed.append('WinkelZ')
            outfile.write(' WinkelZ="%s"' % self.gds_format_float(self.WinkelZ, input_name='WinkelZ'))
    def exportChildren(self, outfile, level, namespace_='', name_='BeschlaegeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Artikel_ in self.Artikel:
            Artikel_.export(outfile, level, namespace_, name_='Artikel', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Artikel
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BeschlaegeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.PositionZ is not None and 'PositionZ' not in already_processed:
            already_processed.append('PositionZ')
            showIndent(outfile, level)
            outfile.write('PositionZ = %e,\n' % (self.PositionZ,))
        if self.PositionX is not None and 'PositionX' not in already_processed:
            already_processed.append('PositionX')
            showIndent(outfile, level)
            outfile.write('PositionX = %e,\n' % (self.PositionX,))
        if self.PositionY is not None and 'PositionY' not in already_processed:
            already_processed.append('PositionY')
            showIndent(outfile, level)
            outfile.write('PositionY = %e,\n' % (self.PositionY,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        if self.Bezug is not None and 'Bezug' not in already_processed:
            already_processed.append('Bezug')
            showIndent(outfile, level)
            outfile.write('Bezug = "%s",\n' % (self.Bezug,))
        if self.WinkelY is not None and 'WinkelY' not in already_processed:
            already_processed.append('WinkelY')
            showIndent(outfile, level)
            outfile.write('WinkelY = %e,\n' % (self.WinkelY,))
        if self.WinkelX is not None and 'WinkelX' not in already_processed:
            already_processed.append('WinkelX')
            showIndent(outfile, level)
            outfile.write('WinkelX = %e,\n' % (self.WinkelX,))
        if self.WinkelZ is not None and 'WinkelZ' not in already_processed:
            already_processed.append('WinkelZ')
            showIndent(outfile, level)
            outfile.write('WinkelZ = %e,\n' % (self.WinkelZ,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Artikel=[\n')
        level += 1
        for Artikel_ in self.Artikel:
            showIndent(outfile, level)
            outfile.write('model_.ArtikelType(\n')
            Artikel_.exportLiteral(outfile, level, name_='ArtikelType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('PositionZ', node)
        if value is not None and 'PositionZ' not in already_processed:
            already_processed.append('PositionZ')
            try:
                self.PositionZ = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (PositionZ): %s' % exp)
        value = find_attr_value_('PositionX', node)
        if value is not None and 'PositionX' not in already_processed:
            already_processed.append('PositionX')
            try:
                self.PositionX = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (PositionX): %s' % exp)
        value = find_attr_value_('PositionY', node)
        if value is not None and 'PositionY' not in already_processed:
            already_processed.append('PositionY')
            try:
                self.PositionY = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (PositionY): %s' % exp)
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        value = find_attr_value_('Bezug', node)
        if value is not None and 'Bezug' not in already_processed:
            already_processed.append('Bezug')
            self.Bezug = value
        value = find_attr_value_('WinkelY', node)
        if value is not None and 'WinkelY' not in already_processed:
            already_processed.append('WinkelY')
            try:
                self.WinkelY = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (WinkelY): %s' % exp)
        value = find_attr_value_('WinkelX', node)
        if value is not None and 'WinkelX' not in already_processed:
            already_processed.append('WinkelX')
            try:
                self.WinkelX = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (WinkelX): %s' % exp)
        value = find_attr_value_('WinkelZ', node)
        if value is not None and 'WinkelZ' not in already_processed:
            already_processed.append('WinkelZ')
            try:
                self.WinkelZ = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (WinkelZ): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Artikel':
            obj_ = ArtikelType.factory()
            obj_.build(child_)
            self.Artikel.append(obj_)
# end class BeschlaegeType


class HolzschubkastenType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Quader=None, Zargendicke=None, Bodendicke=None, Nischentiefe=None, Holzschubkastenhoehe=None, Rueckwandhoehe=None):
        self.Name = _cast(None, Name)
        self.Quader = Quader
        self.Zargendicke = Zargendicke
        self.Bodendicke = Bodendicke
        self.Nischentiefe = Nischentiefe
        self.Holzschubkastenhoehe = Holzschubkastenhoehe
        self.Rueckwandhoehe = Rueckwandhoehe
    def factory(*args_, **kwargs_):
        if HolzschubkastenType.subclass:
            return HolzschubkastenType.subclass(*args_, **kwargs_)
        else:
            return HolzschubkastenType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Quader(self): return self.Quader
    def set_Quader(self, Quader): self.Quader = Quader
    def get_Zargendicke(self): return self.Zargendicke
    def set_Zargendicke(self, Zargendicke): self.Zargendicke = Zargendicke
    def get_Bodendicke(self): return self.Bodendicke
    def set_Bodendicke(self, Bodendicke): self.Bodendicke = Bodendicke
    def get_Nischentiefe(self): return self.Nischentiefe
    def set_Nischentiefe(self, Nischentiefe): self.Nischentiefe = Nischentiefe
    def get_Holzschubkastenhoehe(self): return self.Holzschubkastenhoehe
    def set_Holzschubkastenhoehe(self, Holzschubkastenhoehe): self.Holzschubkastenhoehe = Holzschubkastenhoehe
    def get_Rueckwandhoehe(self): return self.Rueckwandhoehe
    def set_Rueckwandhoehe(self, Rueckwandhoehe): self.Rueckwandhoehe = Rueckwandhoehe
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def export(self, outfile, level, namespace_='', name_='HolzschubkastenType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HolzschubkastenType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HolzschubkastenType'):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='HolzschubkastenType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Quader is not None:
            self.Quader.export(outfile, level, namespace_, name_='Quader', pretty_print=pretty_print)
        if self.Zargendicke is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sZargendicke>%s</%sZargendicke>%s' % (namespace_, self.gds_format_float(self.Zargendicke, input_name='Zargendicke'), namespace_, eol_))
        if self.Bodendicke is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBodendicke>%s</%sBodendicke>%s' % (namespace_, self.gds_format_float(self.Bodendicke, input_name='Bodendicke'), namespace_, eol_))
        if self.Nischentiefe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNischentiefe>%s</%sNischentiefe>%s' % (namespace_, self.gds_format_float(self.Nischentiefe, input_name='Nischentiefe'), namespace_, eol_))
        if self.Holzschubkastenhoehe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHolzschubkastenhoehe>%s</%sHolzschubkastenhoehe>%s' % (namespace_, self.gds_format_float(self.Holzschubkastenhoehe, input_name='Holzschubkastenhoehe'), namespace_, eol_))
        if self.Rueckwandhoehe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRueckwandhoehe>%s</%sRueckwandhoehe>%s' % (namespace_, self.gds_format_float(self.Rueckwandhoehe, input_name='Rueckwandhoehe'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.Quader is not None or
            self.Zargendicke is not None or
            self.Bodendicke is not None or
            self.Nischentiefe is not None or
            self.Holzschubkastenhoehe is not None or
            self.Rueckwandhoehe is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='HolzschubkastenType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Quader is not None:
            showIndent(outfile, level)
            outfile.write('Quader=model_.QuaderType(\n')
            self.Quader.exportLiteral(outfile, level, name_='Quader')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Zargendicke is not None:
            showIndent(outfile, level)
            outfile.write('Zargendicke=%e,\n' % self.Zargendicke)
        if self.Bodendicke is not None:
            showIndent(outfile, level)
            outfile.write('Bodendicke=%e,\n' % self.Bodendicke)
        if self.Nischentiefe is not None:
            showIndent(outfile, level)
            outfile.write('Nischentiefe=%e,\n' % self.Nischentiefe)
        if self.Holzschubkastenhoehe is not None:
            showIndent(outfile, level)
            outfile.write('Holzschubkastenhoehe=%e,\n' % self.Holzschubkastenhoehe)
        if self.Rueckwandhoehe is not None:
            showIndent(outfile, level)
            outfile.write('Rueckwandhoehe=%e,\n' % self.Rueckwandhoehe)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Quader':
            obj_ = QuaderType.factory()
            obj_.build(child_)
            self.set_Quader(obj_)
        elif nodeName_ == 'Zargendicke':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Zargendicke')
            self.Zargendicke = fval_
        elif nodeName_ == 'Bodendicke':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Bodendicke')
            self.Bodendicke = fval_
        elif nodeName_ == 'Nischentiefe':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Nischentiefe')
            self.Nischentiefe = fval_
        elif nodeName_ == 'Holzschubkastenhoehe':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Holzschubkastenhoehe')
            self.Holzschubkastenhoehe = fval_
        elif nodeName_ == 'Rueckwandhoehe':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Rueckwandhoehe')
            self.Rueckwandhoehe = fval_
# end class HolzschubkastenType


class InnenFachType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Boden=None):
        self.Name = _cast(None, Name)
        if Boden is None:
            self.Boden = []
        else:
            self.Boden = Boden
    def factory(*args_, **kwargs_):
        if InnenFachType.subclass:
            return InnenFachType.subclass(*args_, **kwargs_)
        else:
            return InnenFachType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Boden(self): return self.Boden
    def set_Boden(self, Boden): self.Boden = Boden
    def add_Boden(self, value): self.Boden.append(value)
    def insert_Boden(self, index, value): self.Boden[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def export(self, outfile, level, namespace_='', name_='InnenFachType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InnenFachType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InnenFachType'):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='InnenFachType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Boden_ in self.Boden:
            Boden_.export(outfile, level, namespace_, name_='Boden', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Boden
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='InnenFachType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Boden=[\n')
        level += 1
        for Boden_ in self.Boden:
            showIndent(outfile, level)
            outfile.write('model_.GeometryType(\n')
            Boden_.exportLiteral(outfile, level, name_='GeometryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Boden':
            class_obj_ = self.get_class_obj_(child_, GeometryType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Boden.append(obj_)
# end class InnenFachType


class FachType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Hoehe=None, Tiefe=None, Breite=None):
        self.Hoehe = Hoehe
        self.Tiefe = Tiefe
        self.Breite = Breite
    def factory(*args_, **kwargs_):
        if FachType.subclass:
            return FachType.subclass(*args_, **kwargs_)
        else:
            return FachType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Hoehe(self): return self.Hoehe
    def set_Hoehe(self, Hoehe): self.Hoehe = Hoehe
    def get_Tiefe(self): return self.Tiefe
    def set_Tiefe(self, Tiefe): self.Tiefe = Tiefe
    def get_Breite(self): return self.Breite
    def set_Breite(self, Breite): self.Breite = Breite
    def export(self, outfile, level, namespace_='', name_='FachType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FachType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FachType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FachType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Hoehe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHoehe>%s</%sHoehe>%s' % (namespace_, self.gds_format_float(self.Hoehe, input_name='Hoehe'), namespace_, eol_))
        if self.Tiefe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTiefe>%s</%sTiefe>%s' % (namespace_, self.gds_format_float(self.Tiefe, input_name='Tiefe'), namespace_, eol_))
        if self.Breite is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBreite>%s</%sBreite>%s' % (namespace_, self.gds_format_float(self.Breite, input_name='Breite'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.Hoehe is not None or
            self.Tiefe is not None or
            self.Breite is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FachType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Hoehe is not None:
            showIndent(outfile, level)
            outfile.write('Hoehe=%e,\n' % self.Hoehe)
        if self.Tiefe is not None:
            showIndent(outfile, level)
            outfile.write('Tiefe=%e,\n' % self.Tiefe)
        if self.Breite is not None:
            showIndent(outfile, level)
            outfile.write('Breite=%e,\n' % self.Breite)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Hoehe':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Hoehe')
            self.Hoehe = fval_
        elif nodeName_ == 'Tiefe':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Tiefe')
            self.Tiefe = fval_
        elif nodeName_ == 'Breite':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Breite')
            self.Breite = fval_
# end class FachType


class SERVODRIVEType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Beschlaege=None):
        self.Beschlaege = Beschlaege
    def factory(*args_, **kwargs_):
        if SERVODRIVEType.subclass:
            return SERVODRIVEType.subclass(*args_, **kwargs_)
        else:
            return SERVODRIVEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Beschlaege(self): return self.Beschlaege
    def set_Beschlaege(self, Beschlaege): self.Beschlaege = Beschlaege
    def export(self, outfile, level, namespace_='', name_='SERVODRIVEType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SERVODRIVEType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SERVODRIVEType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SERVODRIVEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Beschlaege is not None:
            self.Beschlaege.export(outfile, level, namespace_, name_='Beschlaege', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Beschlaege is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SERVODRIVEType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Beschlaege is not None:
            showIndent(outfile, level)
            outfile.write('Beschlaege=model_.BeschlaegeType(\n')
            self.Beschlaege.exportLiteral(outfile, level, name_='Beschlaege')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Beschlaege':
            obj_ = BeschlaegeType.factory()
            obj_.build(child_)
            self.set_Beschlaege(obj_)
# end class SERVODRIVEType


class QuaderType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, aufd=None, mode=None, dir=None, Position=None, Orientierung=None, Hoehe=None, PunktC=None, Handle=None, Linien=None, View=None, Punkte=None, Fasen=None, Verrundung=None, Nut=None, Falz=None, Bohrungen=None):
        self.aufd = _cast(None, aufd)
        self.mode = _cast(None, mode)
        self.dir = _cast(None, dir)
        self.Position = Position
        self.Orientierung = Orientierung
        self.Hoehe = Hoehe
        self.PunktC = PunktC
        self.Handle = Handle
        self.Linien = Linien
        self.View = View
        self.Punkte = Punkte
        self.Fasen = Fasen
        if Verrundung is None:
            self.Verrundung = []
        else:
            self.Verrundung = Verrundung
        if Nut is None:
            self.Nut = []
        else:
            self.Nut = Nut
        self.Falz = Falz
        if Bohrungen is None:
            self.Bohrungen = []
        else:
            self.Bohrungen = Bohrungen
    def factory(*args_, **kwargs_):
        if QuaderType.subclass:
            return QuaderType.subclass(*args_, **kwargs_)
        else:
            return QuaderType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Position(self): return self.Position
    def set_Position(self, Position): self.Position = Position
    def get_Orientierung(self): return self.Orientierung
    def set_Orientierung(self, Orientierung): self.Orientierung = Orientierung
    def get_Hoehe(self): return self.Hoehe
    def set_Hoehe(self, Hoehe): self.Hoehe = Hoehe
    def get_PunktC(self): return self.PunktC
    def set_PunktC(self, PunktC): self.PunktC = PunktC
    def get_Handle(self): return self.Handle
    def set_Handle(self, Handle): self.Handle = Handle
    def get_Linien(self): return self.Linien
    def set_Linien(self, Linien): self.Linien = Linien
    def get_View(self): return self.View
    def set_View(self, View): self.View = View
    def get_Punkte(self): return self.Punkte
    def set_Punkte(self, Punkte): self.Punkte = Punkte
    def get_Fasen(self): return self.Fasen
    def set_Fasen(self, Fasen): self.Fasen = Fasen
    def get_Verrundung(self): return self.Verrundung
    def set_Verrundung(self, Verrundung): self.Verrundung = Verrundung
    def add_Verrundung(self, value): self.Verrundung.append(value)
    def insert_Verrundung(self, index, value): self.Verrundung[index] = value
    def get_Nut(self): return self.Nut
    def set_Nut(self, Nut): self.Nut = Nut
    def add_Nut(self, value): self.Nut.append(value)
    def insert_Nut(self, index, value): self.Nut[index] = value
    def get_Falz(self): return self.Falz
    def set_Falz(self, Falz): self.Falz = Falz
    def get_Bohrungen(self): return self.Bohrungen
    def set_Bohrungen(self, Bohrungen): self.Bohrungen = Bohrungen
    def add_Bohrungen(self, value): self.Bohrungen.append(value)
    def insert_Bohrungen(self, index, value): self.Bohrungen[index] = value
    def get_aufd(self): return self.aufd
    def set_aufd(self, aufd): self.aufd = aufd
    def get_mode(self): return self.mode
    def set_mode(self, mode): self.mode = mode
    def get_dir(self): return self.dir
    def set_dir(self, dir): self.dir = dir
    def export(self, outfile, level, namespace_='', name_='QuaderType', namespacedef_='', pretty_print=True):
        gTypeQuader,sec_X,pos_Y,pos_Z = self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QuaderType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
        self.makeDraw(gTypeQuader,sec_X,pos_Y,pos_Z) # For K3Mebel add
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QuaderType'):
        if self.aufd is not None and 'aufd' not in already_processed:
            already_processed.append('aufd')
            outfile.write(' aufd=%s' % (self.gds_format_string(quote_attrib(self.aufd), input_name='aufd'), ))
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.append('mode')
            outfile.write(' mode=%s' % (self.gds_format_string(quote_attrib(self.mode), input_name='mode'), ))
        if self.dir is not None and 'dir' not in already_processed:
            already_processed.append('dir')
            outfile.write(' dir=%s' % (self.gds_format_string(quote_attrib(self.dir), input_name='dir'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QuaderType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Position is not None:
            self.Position.export(outfile, level, namespace_, name_='Position', pretty_print=pretty_print)
        if self.Orientierung is not None:
            self.Orientierung.export(outfile, level, namespace_, name_='Orientierung', pretty_print=pretty_print)
        if self.Hoehe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHoehe>%s</%sHoehe>%s' % (namespace_, self.gds_format_float(self.Hoehe, input_name='Hoehe'), namespace_, eol_))
        if self.PunktC is not None:
            self.PunktC.export(outfile, level, namespace_, name_='PunktC', pretty_print=pretty_print)
        if self.Handle is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHandle>%s</%sHandle>%s' % (namespace_, self.gds_format_integer(self.Handle, input_name='Handle'), namespace_, eol_))
        if self.Linien is not None:
            self.Linien.export(outfile, level, namespace_, name_='Linien', pretty_print=pretty_print)
        if self.View is not None:
            self.View.export(outfile, level, namespace_, name_='View', pretty_print=pretty_print)
        if self.Punkte is not None:
            self.Punkte.export(outfile, level, namespace_, name_='Punkte', pretty_print=pretty_print)
        if self.Fasen is not None:
            self.Fasen.export(outfile, level, namespace_, name_='Fasen', pretty_print=pretty_print)
        for Verrundung_ in self.Verrundung:
            Verrundung_.export(outfile, level, namespace_, name_='Verrundung', pretty_print=pretty_print)
        for Nut_ in self.Nut:
            Nut_.export(outfile, level, namespace_, name_='Nut', pretty_print=pretty_print)
        if self.Falz is not None:
            self.Falz.export(outfile, level, namespace_, name_='Falz', pretty_print=pretty_print)
        for Bohrungen_ in self.Bohrungen:
            Bohrungen_.export(outfile, level, namespace_, name_='Bohrungen', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Position is not None or
            self.Orientierung is not None or
            self.Hoehe is not None or
            self.PunktC is not None or
            self.Handle is not None or
            self.Linien is not None or
            self.View is not None or
            self.Punkte is not None or
            self.Fasen is not None or
            self.Verrundung or
            self.Nut or
            self.Falz is not None or
            self.Bohrungen
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='QuaderType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.aufd is not None and 'aufd' not in already_processed:
            already_processed.append('aufd')
            showIndent(outfile, level)
            outfile.write('aufd = "%s",\n' % (self.aufd,))
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.append('mode')
            showIndent(outfile, level)
            outfile.write('mode = "%s",\n' % (self.mode,))
        if self.dir is not None and 'dir' not in already_processed:
            already_processed.append('dir')
            showIndent(outfile, level)
            outfile.write('dir = "%s",\n' % (self.dir,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Position is not None:
            showIndent(outfile, level)
            outfile.write('Position=model_.PunktType(\n')
            self.Position.exportLiteral(outfile, level, name_='Position')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Orientierung is not None:
            showIndent(outfile, level)
            outfile.write('Orientierung=model_.PunktType(\n')
            self.Orientierung.exportLiteral(outfile, level, name_='Orientierung')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Hoehe is not None:
            showIndent(outfile, level)
            outfile.write('Hoehe=%e,\n' % self.Hoehe)
        if self.PunktC is not None:
            showIndent(outfile, level)
            outfile.write('PunktC=model_.PunktType(\n')
            self.PunktC.exportLiteral(outfile, level, name_='PunktC')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Handle is not None:
            showIndent(outfile, level)
            outfile.write('Handle=%d,\n' % self.Handle)
        if self.Linien is not None:
            showIndent(outfile, level)
            outfile.write('Linien=model_.LinienType(\n')
            self.Linien.exportLiteral(outfile, level, name_='Linien')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.View is not None:
            showIndent(outfile, level)
            outfile.write('View=model_.ViewType(\n')
            self.View.exportLiteral(outfile, level, name_='View')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Punkte is not None:
            showIndent(outfile, level)
            outfile.write('Punkte=model_.PunkteType(\n')
            self.Punkte.exportLiteral(outfile, level, name_='Punkte')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Fasen is not None:
            showIndent(outfile, level)
            outfile.write('Fasen=model_.FasenType(\n')
            self.Fasen.exportLiteral(outfile, level, name_='Fasen')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Verrundung=[\n')
        level += 1
        for Verrundung_ in self.Verrundung:
            showIndent(outfile, level)
            outfile.write('model_.VerrundungType(\n')
            Verrundung_.exportLiteral(outfile, level, name_='VerrundungType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Nut=[\n')
        level += 1
        for Nut_ in self.Nut:
            showIndent(outfile, level)
            outfile.write('model_.NutFalzType(\n')
            Nut_.exportLiteral(outfile, level, name_='NutFalzType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Falz is not None:
            showIndent(outfile, level)
            outfile.write('Falz=model_.NutFalzType(\n')
            self.Falz.exportLiteral(outfile, level, name_='Falz')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Bohrungen=[\n')
        level += 1
        for Bohrungen_ in self.Bohrungen:
            showIndent(outfile, level)
            outfile.write('model_.BohrungenType(\n')
            Bohrungen_.exportLiteral(outfile, level, name_='BohrungenType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aufd', node)
        if value is not None and 'aufd' not in already_processed:
            already_processed.append('aufd')
            self.aufd = value
        value = find_attr_value_('mode', node)
        if value is not None and 'mode' not in already_processed:
            already_processed.append('mode')
            self.mode = value
        value = find_attr_value_('dir', node)
        if value is not None and 'dir' not in already_processed:
            already_processed.append('dir')
            self.dir = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Position':
            obj_ = PunktType.factory()
            obj_.build(child_)
            self.set_Position(obj_)
        elif nodeName_ == 'Orientierung':
            obj_ = PunktType.factory()
            obj_.build(child_)
            self.set_Orientierung(obj_)
        elif nodeName_ == 'Hoehe':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Hoehe')
            self.Hoehe = fval_
        elif nodeName_ == 'PunktC':
            obj_ = PunktType.factory()
            obj_.build(child_)
            self.set_PunktC(obj_)
        elif nodeName_ == 'Handle':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Handle')
            self.Handle = ival_
        elif nodeName_ == 'Linien':
            obj_ = LinienType.factory()
            obj_.build(child_)
            self.set_Linien(obj_)
        elif nodeName_ == 'View':
            obj_ = ViewType.factory()
            obj_.build(child_)
            self.set_View(obj_)
        elif nodeName_ == 'Punkte':
            obj_ = PunkteType.factory()
            obj_.build(child_)
            self.set_Punkte(obj_)
        elif nodeName_ == 'Fasen':
            obj_ = FasenType.factory()
            obj_.build(child_)
            self.set_Fasen(obj_)
        elif nodeName_ == 'Verrundung':
            obj_ = VerrundungType.factory()
            obj_.build(child_)
            self.Verrundung.append(obj_)
        elif nodeName_ == 'Nut':
            obj_ = NutFalzType.factory()
            obj_.build(child_)
            self.Nut.append(obj_)
        elif nodeName_ == 'Falz':
            obj_ = NutFalzType.factory()
            obj_.build(child_)
            self.set_Falz(obj_)
        elif nodeName_ == 'Bohrungen':
            obj_ = BohrungenType.factory()
            obj_.build(child_)
            self.Bohrungen.append(obj_)
# end class QuaderType


class PolygonType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Eckpunkte=None, Position=None, Orientierung=None, Hoehe=None, PunktB=None, PunktC=None, PunktD=None, PunktE=None, PunktF=None, PunktG=None, PunktH=None, Handle=None, Verrundung=None, Falz=None, Bohrungen=None):
        self.Eckpunkte = _cast(int, Eckpunkte)
        self.Position = Position
        self.Orientierung = Orientierung
        self.Hoehe = Hoehe
        self.PunktB = PunktB
        self.PunktC = PunktC
        self.PunktD = PunktD
        self.PunktE = PunktE
        self.PunktF = PunktF
        self.PunktG = PunktG
        self.PunktH = PunktH
        self.Handle = Handle
        self.Verrundung = Verrundung
        self.Falz = Falz
        if Bohrungen is None:
            self.Bohrungen = []
        else:
            self.Bohrungen = Bohrungen
    def factory(*args_, **kwargs_):
        if PolygonType.subclass:
            return PolygonType.subclass(*args_, **kwargs_)
        else:
            return PolygonType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Position(self): return self.Position
    def set_Position(self, Position): self.Position = Position
    def get_Orientierung(self): return self.Orientierung
    def set_Orientierung(self, Orientierung): self.Orientierung = Orientierung
    def get_Hoehe(self): return self.Hoehe
    def set_Hoehe(self, Hoehe): self.Hoehe = Hoehe
    def get_PunktB(self): return self.PunktB
    def set_PunktB(self, PunktB): self.PunktB = PunktB
    def get_PunktC(self): return self.PunktC
    def set_PunktC(self, PunktC): self.PunktC = PunktC
    def get_PunktD(self): return self.PunktD
    def set_PunktD(self, PunktD): self.PunktD = PunktD
    def get_PunktE(self): return self.PunktE
    def set_PunktE(self, PunktE): self.PunktE = PunktE
    def get_PunktF(self): return self.PunktF
    def set_PunktF(self, PunktF): self.PunktF = PunktF
    def get_PunktG(self): return self.PunktG
    def set_PunktG(self, PunktG): self.PunktG = PunktG
    def get_PunktH(self): return self.PunktH
    def set_PunktH(self, PunktH): self.PunktH = PunktH
    def get_Handle(self): return self.Handle
    def set_Handle(self, Handle): self.Handle = Handle
    def get_Verrundung(self): return self.Verrundung
    def set_Verrundung(self, Verrundung): self.Verrundung = Verrundung
    def get_Falz(self): return self.Falz
    def set_Falz(self, Falz): self.Falz = Falz
    def get_Bohrungen(self): return self.Bohrungen
    def set_Bohrungen(self, Bohrungen): self.Bohrungen = Bohrungen
    def add_Bohrungen(self, value): self.Bohrungen.append(value)
    def insert_Bohrungen(self, index, value): self.Bohrungen[index] = value
    def get_Eckpunkte(self): return self.Eckpunkte
    def set_Eckpunkte(self, Eckpunkte): self.Eckpunkte = Eckpunkte
    def export(self, outfile, level, namespace_='', name_='PolygonType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PolygonType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PolygonType'):
        if self.Eckpunkte is not None and 'Eckpunkte' not in already_processed:
            already_processed.append('Eckpunkte')
            outfile.write(' Eckpunkte="%s"' % self.gds_format_integer(self.Eckpunkte, input_name='Eckpunkte'))
    def exportChildren(self, outfile, level, namespace_='', name_='PolygonType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Position is not None:
            self.Position.export(outfile, level, namespace_, name_='Position', pretty_print=pretty_print)
        if self.Orientierung is not None:
            self.Orientierung.export(outfile, level, namespace_, name_='Orientierung', pretty_print=pretty_print)
        if self.Hoehe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHoehe>%s</%sHoehe>%s' % (namespace_, self.gds_format_float(self.Hoehe, input_name='Hoehe'), namespace_, eol_))
        if self.PunktB is not None:
            self.PunktB.export(outfile, level, namespace_, name_='PunktB', pretty_print=pretty_print)
        if self.PunktC is not None:
            self.PunktC.export(outfile, level, namespace_, name_='PunktC', pretty_print=pretty_print)
        if self.PunktD is not None:
            self.PunktD.export(outfile, level, namespace_, name_='PunktD', pretty_print=pretty_print)
        if self.PunktE is not None:
            self.PunktE.export(outfile, level, namespace_, name_='PunktE', pretty_print=pretty_print)
        if self.PunktF is not None:
            self.PunktF.export(outfile, level, namespace_, name_='PunktF', pretty_print=pretty_print)
        if self.PunktG is not None:
            self.PunktG.export(outfile, level, namespace_, name_='PunktG', pretty_print=pretty_print)
        if self.PunktH is not None:
            self.PunktH.export(outfile, level, namespace_, name_='PunktH', pretty_print=pretty_print)
        if self.Handle is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHandle>%s</%sHandle>%s' % (namespace_, self.gds_format_string(quote_xml(self.Handle), input_name='Handle'), namespace_, eol_))
        if self.Verrundung is not None:
            self.Verrundung.export(outfile, level, namespace_, name_='Verrundung', pretty_print=pretty_print)
        if self.Falz is not None:
            self.Falz.export(outfile, level, namespace_, name_='Falz', pretty_print=pretty_print)
        for Bohrungen_ in self.Bohrungen:
            Bohrungen_.export(outfile, level, namespace_, name_='Bohrungen', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Position is not None or
            self.Orientierung is not None or
            self.Hoehe is not None or
            self.PunktB is not None or
            self.PunktC is not None or
            self.PunktD is not None or
            self.PunktE is not None or
            self.PunktF is not None or
            self.PunktG is not None or
            self.PunktH is not None or
            self.Handle is not None or
            self.Verrundung is not None or
            self.Falz is not None or
            self.Bohrungen
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PolygonType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Eckpunkte is not None and 'Eckpunkte' not in already_processed:
            already_processed.append('Eckpunkte')
            showIndent(outfile, level)
            outfile.write('Eckpunkte = %d,\n' % (self.Eckpunkte,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Position is not None:
            showIndent(outfile, level)
            outfile.write('Position=model_.PunktType(\n')
            self.Position.exportLiteral(outfile, level, name_='Position')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Orientierung is not None:
            showIndent(outfile, level)
            outfile.write('Orientierung=model_.PunktType(\n')
            self.Orientierung.exportLiteral(outfile, level, name_='Orientierung')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Hoehe is not None:
            showIndent(outfile, level)
            outfile.write('Hoehe=%e,\n' % self.Hoehe)
        if self.PunktB is not None:
            showIndent(outfile, level)
            outfile.write('PunktB=model_.PunktType(\n')
            self.PunktB.exportLiteral(outfile, level, name_='PunktB')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PunktC is not None:
            showIndent(outfile, level)
            outfile.write('PunktC=model_.PunktType(\n')
            self.PunktC.exportLiteral(outfile, level, name_='PunktC')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PunktD is not None:
            showIndent(outfile, level)
            outfile.write('PunktD=model_.PunktType(\n')
            self.PunktD.exportLiteral(outfile, level, name_='PunktD')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PunktE is not None:
            showIndent(outfile, level)
            outfile.write('PunktE=model_.PunktType(\n')
            self.PunktE.exportLiteral(outfile, level, name_='PunktE')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PunktF is not None:
            showIndent(outfile, level)
            outfile.write('PunktF=model_.PunktType(\n')
            self.PunktF.exportLiteral(outfile, level, name_='PunktF')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PunktG is not None:
            showIndent(outfile, level)
            outfile.write('PunktG=model_.PunktType(\n')
            self.PunktG.exportLiteral(outfile, level, name_='PunktG')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PunktH is not None:
            showIndent(outfile, level)
            outfile.write('PunktH=model_.PunktType(\n')
            self.PunktH.exportLiteral(outfile, level, name_='PunktH')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Handle is not None:
            showIndent(outfile, level)
            outfile.write('Handle=%s,\n' % quote_python(self.Handle))
        if self.Verrundung is not None:
            showIndent(outfile, level)
            outfile.write('Verrundung=model_.VerrundungType(\n')
            self.Verrundung.exportLiteral(outfile, level, name_='Verrundung')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Falz is not None:
            showIndent(outfile, level)
            outfile.write('Falz=model_.NutFalzType(\n')
            self.Falz.exportLiteral(outfile, level, name_='Falz')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Bohrungen=[\n')
        level += 1
        for Bohrungen_ in self.Bohrungen:
            showIndent(outfile, level)
            outfile.write('model_.BohrungenType(\n')
            Bohrungen_.exportLiteral(outfile, level, name_='BohrungenType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Eckpunkte', node)
        if value is not None and 'Eckpunkte' not in already_processed:
            already_processed.append('Eckpunkte')
            try:
                self.Eckpunkte = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Position':
            obj_ = PunktType.factory()
            obj_.build(child_)
            self.set_Position(obj_)
        elif nodeName_ == 'Orientierung':
            obj_ = PunktType.factory()
            obj_.build(child_)
            self.set_Orientierung(obj_)
        elif nodeName_ == 'Hoehe':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Hoehe')
            self.Hoehe = fval_
        elif nodeName_ == 'PunktB':
            obj_ = PunktType.factory()
            obj_.build(child_)
            self.set_PunktB(obj_)
        elif nodeName_ == 'PunktC':
            obj_ = PunktType.factory()
            obj_.build(child_)
            self.set_PunktC(obj_)
        elif nodeName_ == 'PunktD':
            obj_ = PunktType.factory()
            obj_.build(child_)
            self.set_PunktD(obj_)
        elif nodeName_ == 'PunktE':
            obj_ = PunktType.factory()
            obj_.build(child_)
            self.set_PunktE(obj_)
        elif nodeName_ == 'PunktF':
            obj_ = PunktType.factory()
            obj_.build(child_)
            self.set_PunktF(obj_)
        elif nodeName_ == 'PunktG':
            obj_ = PunktType.factory()
            obj_.build(child_)
            self.set_PunktG(obj_)
        elif nodeName_ == 'PunktH':
            obj_ = PunktType.factory()
            obj_.build(child_)
            self.set_PunktH(obj_)
        elif nodeName_ == 'Handle':
            Handle_ = child_.text
            Handle_ = self.gds_validate_string(Handle_, node, 'Handle')
            self.Handle = Handle_
        elif nodeName_ == 'Verrundung':
            obj_ = VerrundungType.factory()
            obj_.build(child_)
            self.set_Verrundung(obj_)
        elif nodeName_ == 'Falz':
            obj_ = NutFalzType.factory()
            obj_.build(child_)
            self.set_Falz(obj_)
        elif nodeName_ == 'Bohrungen':
            obj_ = BohrungenType.factory()
            obj_.build(child_)
            self.Bohrungen.append(obj_)
# end class PolygonType


class NutFalzType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Position=None, Orientierung=None, PunktB=None, Tiefe=None, Radius=None):
        self.Position = Position
        self.Orientierung = Orientierung
        self.PunktB = PunktB
        self.Tiefe = Tiefe
        self.Radius = Radius
    def factory(*args_, **kwargs_):
        if NutFalzType.subclass:
            return NutFalzType.subclass(*args_, **kwargs_)
        else:
            return NutFalzType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Position(self): return self.Position
    def set_Position(self, Position): self.Position = Position
    def get_Orientierung(self): return self.Orientierung
    def set_Orientierung(self, Orientierung): self.Orientierung = Orientierung
    def get_PunktB(self): return self.PunktB
    def set_PunktB(self, PunktB): self.PunktB = PunktB
    def get_Tiefe(self): return self.Tiefe
    def set_Tiefe(self, Tiefe): self.Tiefe = Tiefe
    def get_Radius(self): return self.Radius
    def set_Radius(self, Radius): self.Radius = Radius
    def export(self, outfile, level, namespace_='', name_='NutFalzType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NutFalzType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NutFalzType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NutFalzType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Position is not None:
            self.Position.export(outfile, level, namespace_, name_='Position', pretty_print=pretty_print)
        if self.Orientierung is not None:
            self.Orientierung.export(outfile, level, namespace_, name_='Orientierung', pretty_print=pretty_print)
        if self.PunktB is not None:
            self.PunktB.export(outfile, level, namespace_, name_='PunktB', pretty_print=pretty_print)
        if self.Tiefe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTiefe>%s</%sTiefe>%s' % (namespace_, self.gds_format_float(self.Tiefe, input_name='Tiefe'), namespace_, eol_))
        if self.Radius is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRadius>%s</%sRadius>%s' % (namespace_, self.gds_format_float(self.Radius, input_name='Radius'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.Position is not None or
            self.Orientierung is not None or
            self.PunktB is not None or
            self.Tiefe is not None or
            self.Radius is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NutFalzType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Position is not None:
            showIndent(outfile, level)
            outfile.write('Position=model_.PunktType(\n')
            self.Position.exportLiteral(outfile, level, name_='Position')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Orientierung is not None:
            showIndent(outfile, level)
            outfile.write('Orientierung=model_.PunktType(\n')
            self.Orientierung.exportLiteral(outfile, level, name_='Orientierung')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PunktB is not None:
            showIndent(outfile, level)
            outfile.write('PunktB=model_.PunktType(\n')
            self.PunktB.exportLiteral(outfile, level, name_='PunktB')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Tiefe is not None:
            showIndent(outfile, level)
            outfile.write('Tiefe=%e,\n' % self.Tiefe)
        if self.Radius is not None:
            showIndent(outfile, level)
            outfile.write('Radius=%e,\n' % self.Radius)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Position':
            obj_ = PunktType.factory()
            obj_.build(child_)
            self.set_Position(obj_)
        elif nodeName_ == 'Orientierung':
            obj_ = PunktType.factory()
            obj_.build(child_)
            self.set_Orientierung(obj_)
        elif nodeName_ == 'PunktB':
            obj_ = PunktType.factory()
            obj_.build(child_)
            self.set_PunktB(obj_)
        elif nodeName_ == 'Tiefe':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Tiefe')
            self.Tiefe = fval_
        elif nodeName_ == 'Radius':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Radius')
            self.Radius = fval_
# end class NutFalzType


class BohrbildType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, HauptBohrbild=None, Name=None, Blockname=None, Position=None, Drehung=None, LayerZuordnung=None, Bohrtiefe=None, Bohrradius=None):
        self.HauptBohrbild = _cast(None, HauptBohrbild)
        self.Name = _cast(None, Name)
        self.Blockname = _cast(None, Blockname)
        self.Position = Position
        self.Drehung = Drehung
        self.LayerZuordnung = LayerZuordnung
        if Bohrtiefe is None:
            self.Bohrtiefe = []
        else:
            self.Bohrtiefe = Bohrtiefe
        if Bohrradius is None:
            self.Bohrradius = []
        else:
            self.Bohrradius = Bohrradius
    def factory(*args_, **kwargs_):
        if BohrbildType.subclass:
            return BohrbildType.subclass(*args_, **kwargs_)
        else:
            return BohrbildType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Position(self): return self.Position
    def set_Position(self, Position): self.Position = Position
    def get_Drehung(self): return self.Drehung
    def set_Drehung(self, Drehung): self.Drehung = Drehung
    def get_LayerZuordnung(self): return self.LayerZuordnung
    def set_LayerZuordnung(self, LayerZuordnung): self.LayerZuordnung = LayerZuordnung
    def get_Bohrtiefe(self): return self.Bohrtiefe
    def set_Bohrtiefe(self, Bohrtiefe): self.Bohrtiefe = Bohrtiefe
    def add_Bohrtiefe(self, value): self.Bohrtiefe.append(value)
    def insert_Bohrtiefe(self, index, value): self.Bohrtiefe[index] = value
    def get_Bohrradius(self): return self.Bohrradius
    def set_Bohrradius(self, Bohrradius): self.Bohrradius = Bohrradius
    def add_Bohrradius(self, value): self.Bohrradius.append(value)
    def insert_Bohrradius(self, index, value): self.Bohrradius[index] = value
    def get_HauptBohrbild(self): return self.HauptBohrbild
    def set_HauptBohrbild(self, HauptBohrbild): self.HauptBohrbild = HauptBohrbild
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Blockname(self): return self.Blockname
    def set_Blockname(self, Blockname): self.Blockname = Blockname
    def export(self, outfile, level, namespace_='', name_='BohrbildType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BohrbildType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BohrbildType'):
        if self.HauptBohrbild is not None and 'HauptBohrbild' not in already_processed:
            already_processed.append('HauptBohrbild')
            outfile.write(' HauptBohrbild=%s' % (self.gds_format_string(quote_attrib(self.HauptBohrbild), input_name='HauptBohrbild'), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name), input_name='Name'), ))
        if self.Blockname is not None and 'Blockname' not in already_processed:
            already_processed.append('Blockname')
            outfile.write(' Blockname=%s' % (self.gds_format_string(quote_attrib(self.Blockname), input_name='Blockname'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BohrbildType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Position is not None:
            self.Position.export(outfile, level, namespace_, name_='Position', pretty_print=pretty_print)
        if self.Drehung is not None:
            self.Drehung.export(outfile, level, namespace_, name_='Drehung', pretty_print=pretty_print)
        if self.LayerZuordnung is not None:
            self.LayerZuordnung.export(outfile, level, namespace_, name_='LayerZuordnung', pretty_print=pretty_print)
        for Bohrtiefe_ in self.Bohrtiefe:
            Bohrtiefe_.export(outfile, level, namespace_, name_='Bohrtiefe', pretty_print=pretty_print)
        for Bohrradius_ in self.Bohrradius:
            Bohrradius_.export(outfile, level, namespace_, name_='Bohrradius', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Position is not None or
            self.Drehung is not None or
            self.LayerZuordnung is not None or
            self.Bohrtiefe or
            self.Bohrradius
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BohrbildType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.HauptBohrbild is not None and 'HauptBohrbild' not in already_processed:
            already_processed.append('HauptBohrbild')
            showIndent(outfile, level)
            outfile.write('HauptBohrbild = "%s",\n' % (self.HauptBohrbild,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        if self.Blockname is not None and 'Blockname' not in already_processed:
            already_processed.append('Blockname')
            showIndent(outfile, level)
            outfile.write('Blockname = "%s",\n' % (self.Blockname,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Position is not None:
            showIndent(outfile, level)
            outfile.write('Position=model_.PunktType(\n')
            self.Position.exportLiteral(outfile, level, name_='Position')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Drehung is not None:
            showIndent(outfile, level)
            outfile.write('Drehung=model_.PunktType(\n')
            self.Drehung.exportLiteral(outfile, level, name_='Drehung')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LayerZuordnung is not None:
            showIndent(outfile, level)
            outfile.write('LayerZuordnung=model_.LayerZuordnungType(\n')
            self.LayerZuordnung.exportLiteral(outfile, level, name_='LayerZuordnung')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Bohrtiefe=[\n')
        level += 1
        for Bohrtiefe_ in self.Bohrtiefe:
            showIndent(outfile, level)
            outfile.write('model_.BohrtiefeType(\n')
            Bohrtiefe_.exportLiteral(outfile, level, name_='BohrtiefeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Bohrradius=[\n')
        level += 1
        for Bohrradius_ in self.Bohrradius:
            showIndent(outfile, level)
            outfile.write('model_.BohrradiusType(\n')
            Bohrradius_.exportLiteral(outfile, level, name_='BohrradiusType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('HauptBohrbild', node)
        if value is not None and 'HauptBohrbild' not in already_processed:
            already_processed.append('HauptBohrbild')
            self.HauptBohrbild = value
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        value = find_attr_value_('Blockname', node)
        if value is not None and 'Blockname' not in already_processed:
            already_processed.append('Blockname')
            self.Blockname = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Position':
            obj_ = PunktType.factory()
            obj_.build(child_)
            self.set_Position(obj_)
        elif nodeName_ == 'Drehung':
            obj_ = PunktType.factory()
            obj_.build(child_)
            self.set_Drehung(obj_)
        elif nodeName_ == 'LayerZuordnung':
            obj_ = LayerZuordnungType.factory()
            obj_.build(child_)
            self.set_LayerZuordnung(obj_)
        elif nodeName_ == 'Bohrtiefe':
            obj_ = BohrtiefeType.factory()
            obj_.build(child_)
            self.Bohrtiefe.append(obj_)
        elif nodeName_ == 'Bohrradius':
            obj_ = BohrradiusType.factory()
            obj_.build(child_)
            self.Bohrradius.append(obj_)
# end class BohrbildType


class BohrungenType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Zylinder=None):
        if Zylinder is None:
            self.Zylinder = []
        else:
            self.Zylinder = Zylinder
    def factory(*args_, **kwargs_):
        if BohrungenType.subclass:
            return BohrungenType.subclass(*args_, **kwargs_)
        else:
            return BohrungenType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Zylinder(self): return self.Zylinder
    def set_Zylinder(self, Zylinder): self.Zylinder = Zylinder
    def add_Zylinder(self, value): self.Zylinder.append(value)
    def insert_Zylinder(self, index, value): self.Zylinder[index] = value
    def export(self, outfile, level, namespace_='', name_='BohrungenType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BohrungenType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BohrungenType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BohrungenType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Zylinder_ in self.Zylinder:
            Zylinder_.export(outfile, level, namespace_, name_='Zylinder', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Zylinder
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BohrungenType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Zylinder=[\n')
        level += 1
        for Zylinder_ in self.Zylinder:
            showIndent(outfile, level)
            outfile.write('model_.ZylinderType(\n')
            Zylinder_.exportLiteral(outfile, level, name_='ZylinderType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Zylinder':
            obj_ = ZylinderType.factory()
            obj_.build(child_)
            self.Zylinder.append(obj_)
# end class BohrungenType


class BohrtiefeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, BT=None):
        if BT is None:
            self.BT = []
        else:
            self.BT = BT
    def factory(*args_, **kwargs_):
        if BohrtiefeType.subclass:
            return BohrtiefeType.subclass(*args_, **kwargs_)
        else:
            return BohrtiefeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BT(self): return self.BT
    def set_BT(self, BT): self.BT = BT
    def add_BT(self, value): self.BT.append(value)
    def insert_BT(self, index, value): self.BT[index] = value
    def export(self, outfile, level, namespace_='', name_='BohrtiefeType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BohrtiefeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BohrtiefeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BohrtiefeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for BT_ in self.BT:
            BT_.export(outfile, level, namespace_, name_='BT', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.BT
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BohrtiefeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('BT=[\n')
        level += 1
        for BT_ in self.BT:
            showIndent(outfile, level)
            outfile.write('model_.DoubleWithId(\n')
            BT_.exportLiteral(outfile, level, name_='DoubleWithId')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BT':
            obj_ = DoubleWithId.factory()
            obj_.build(child_)
            self.BT.append(obj_)
# end class BohrtiefeType


class BohrradiusType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, BR=None):
        if BR is None:
            self.BR = []
        else:
            self.BR = BR
    def factory(*args_, **kwargs_):
        if BohrradiusType.subclass:
            return BohrradiusType.subclass(*args_, **kwargs_)
        else:
            return BohrradiusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BR(self): return self.BR
    def set_BR(self, BR): self.BR = BR
    def add_BR(self, value): self.BR.append(value)
    def insert_BR(self, index, value): self.BR[index] = value
    def export(self, outfile, level, namespace_='', name_='BohrradiusType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BohrradiusType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BohrradiusType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BohrradiusType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for BR_ in self.BR:
            BR_.export(outfile, level, namespace_, name_='BR', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.BR
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BohrradiusType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('BR=[\n')
        level += 1
        for BR_ in self.BR:
            showIndent(outfile, level)
            outfile.write('model_.DoubleWithId(\n')
            BR_.exportLiteral(outfile, level, name_='DoubleWithId')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BR':
            obj_ = DoubleWithId.factory()
            obj_.build(child_)
            self.BR.append(obj_)
# end class BohrradiusType


class ArtikelType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PositionZ=None, PositionX=None, PositionY=None, Name=None, Bezug=None,
    Identnummer=None, Anzahl=None, Oberflaeche=None, Bezeichnung=None, WinkelY=None, WinkelX=None, WinkelZ=None,
    Artikelnummer=None, Artikel=None, Ablaengen=None, Skalierung=None):
        self.PositionZ = _cast(None, PositionZ)
        self.PositionX = _cast(None, PositionX)
        self.PositionY = _cast(None, PositionY)
        self.Name = _cast(None, Name)
        self.Bezug = _cast(None, Bezug)
        self.Identnummer = _cast(None, Identnummer)
        self.Anzahl = _cast(None, Anzahl)
        self.Oberflaeche = _cast(None, Oberflaeche)
        self.Bezeichnung = _cast(None, Bezeichnung)
        self.WinkelY = _cast(None, WinkelY)
        self.WinkelX = _cast(None, WinkelX)
        self.WinkelZ = _cast(None, WinkelZ)
        self.Artikelnummer = _cast(None, Artikelnummer)
        if Artikel is None:
            self.Artikel = []
        else:
            self.Artikel = Artikel
        self.Ablaengen = Ablaengen
        self.Skalierung = Skalierung
    def factory(*args_, **kwargs_):
        if ArtikelType.subclass:
            return ArtikelType.subclass(*args_, **kwargs_)
        else:
            return ArtikelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Artikel(self): return self.Artikel
    def set_Artikel(self, Artikel): self.Artikel = Artikel
    def add_Artikel(self, value): self.Artikel.append(value)
    def insert_Artikel(self, index, value): self.Artikel[index] = value
    def get_Ablaengen(self): return self.Ablaengen
    def set_Ablaengen(self, Ablaengen): self.Ablaengen = Ablaengen
    def get_Skalierung(self): return self.Skalierung
    def set_Skalierung(self, Skalierung): self.Skalierung = Skalierung
    def get_PositionZ(self): return self.PositionZ
    def set_PositionZ(self, PositionZ): self.PositionZ = PositionZ
    def get_PositionX(self): return self.PositionX
    def set_PositionX(self, PositionX): self.PositionX = PositionX
    def get_PositionY(self): return self.PositionY
    def set_PositionY(self, PositionY): self.PositionY = PositionY
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Bezug(self): return self.Bezug
    def set_Bezug(self, Bezug): self.Bezug = Bezug
    def get_Identnummer(self): return self.Identnummer
    def set_Identnummer(self, Identnummer): self.Identnummer = Identnummer
    def get_Anzahl(self): return self.Anzahl
    def set_Anzahl(self, Anzahl): self.Anzahl = Anzahl
    def get_Oberflaeche(self): return self.Oberflaeche
    def set_Oberflaeche(self, Oberflaeche): self.Oberflaeche = Oberflaeche
    def get_Bezeichnung(self): return self.Bezeichnung
    def set_Bezeichnung(self, Bezeichnung): self.Bezeichnung = Bezeichnung
    def get_WinkelY(self): return self.WinkelY
    def set_WinkelY(self, WinkelY): self.WinkelY = WinkelY
    def get_WinkelX(self): return self.WinkelX
    def set_WinkelX(self, WinkelX): self.WinkelX = WinkelX
    def get_WinkelZ(self): return self.WinkelZ
    def set_WinkelZ(self, WinkelZ): self.WinkelZ = WinkelZ
    def get_Artikelnummer(self): return self.Artikelnummer
    def set_Artikelnummer(self, Artikelnummer): self.Artikelnummer = Artikelnummer
    def export(self, outfile, level, namespace_='', name_='ArtikelType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ArtikelType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
            self.GroupChildObjectK3() # For K3Mebel add
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ArtikelType'):
        if self.PositionZ is not None and 'PositionZ' not in already_processed:
            already_processed.append('PositionZ')
            outfile.write(' PositionZ=%s' % (self.gds_format_string(quote_attrib(self.PositionZ), input_name='PositionZ'), ))
        if self.PositionX is not None and 'PositionX' not in already_processed:
            already_processed.append('PositionX')
            outfile.write(' PositionX=%s' % (self.gds_format_string(quote_attrib(self.PositionX), input_name='PositionX'), ))
        if self.PositionY is not None and 'PositionY' not in already_processed:
            already_processed.append('PositionY')
            outfile.write(' PositionY=%s' % (self.gds_format_string(quote_attrib(self.PositionY), input_name='PositionY'), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name), input_name='Name'), ))
        if self.Bezug is not None and 'Bezug' not in already_processed:
            already_processed.append('Bezug')
            outfile.write(' Bezug=%s' % (self.gds_format_string(quote_attrib(self.Bezug), input_name='Bezug'), ))
        if self.Identnummer is not None and 'Identnummer' not in already_processed:
            already_processed.append('Identnummer')
            outfile.write(' Identnummer=%s' % (self.gds_format_string(quote_attrib(self.Identnummer), input_name='Identnummer'), ))
        if self.Anzahl is not None and 'Anzahl' not in already_processed:
            already_processed.append('Anzahl')
            outfile.write(' Anzahl=%s' % (self.gds_format_string(quote_attrib(self.Anzahl), input_name='Anzahl'), ))
        if self.Oberflaeche is not None and 'Oberflaeche' not in already_processed:
            already_processed.append('Oberflaeche')
            outfile.write(' Oberflaeche=%s' % (self.gds_format_string(quote_attrib(self.Oberflaeche), input_name='Oberflaeche'), ))
        if self.Bezeichnung is not None and 'Bezeichnung' not in already_processed:
            already_processed.append('Bezeichnung')
            outfile.write(' Bezeichnung=%s' % (self.gds_format_string(quote_attrib(self.Bezeichnung), input_name='Bezeichnung'), ))
        if self.WinkelY is not None and 'WinkelY' not in already_processed:
            already_processed.append('WinkelY')
            outfile.write(' WinkelY=%s' % (self.gds_format_string(quote_attrib(self.WinkelY), input_name='WinkelY'), ))
        if self.WinkelX is not None and 'WinkelX' not in already_processed:
            already_processed.append('WinkelX')
            outfile.write(' WinkelX=%s' % (self.gds_format_string(quote_attrib(self.WinkelX), input_name='WinkelX'), ))
        if self.WinkelZ is not None and 'WinkelZ' not in already_processed:
            already_processed.append('WinkelZ')
            outfile.write(' WinkelZ=%s' % (self.gds_format_string(quote_attrib(self.WinkelZ), input_name='WinkelZ'), ))
        if self.Artikelnummer is not None and 'Artikelnummer' not in already_processed:
            already_processed.append('Artikelnummer')
            outfile.write(' Artikelnummer=%s' % (self.gds_format_string(quote_attrib(self.Artikelnummer), input_name='Artikelnummer'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ArtikelType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Artikel_ in self.Artikel:
            Artikel_.export(outfile, level, namespace_, name_='Artikel', pretty_print=pretty_print)
        if self.Ablaengen is not None:
            self.Ablaengen.export(outfile, level, namespace_, name_='Ablaengen', pretty_print=pretty_print)
        if self.Skalierung is not None:
            self.Skalierung.export(outfile, level, namespace_, name_='Skalierung', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Artikel or
            self.Ablaengen is not None or
            self.Skalierung is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ArtikelType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.PositionZ is not None and 'PositionZ' not in already_processed:
            already_processed.append('PositionZ')
            showIndent(outfile, level)
            outfile.write('PositionZ = "%s",\n' % (self.PositionZ,))
        if self.PositionX is not None and 'PositionX' not in already_processed:
            already_processed.append('PositionX')
            showIndent(outfile, level)
            outfile.write('PositionX = "%s",\n' % (self.PositionX,))
        if self.PositionY is not None and 'PositionY' not in already_processed:
            already_processed.append('PositionY')
            showIndent(outfile, level)
            outfile.write('PositionY = "%s",\n' % (self.PositionY,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        if self.Bezug is not None and 'Bezug' not in already_processed:
            already_processed.append('Bezug')
            showIndent(outfile, level)
            outfile.write('Bezug = "%s",\n' % (self.Bezug,))
        if self.Identnummer is not None and 'Identnummer' not in already_processed:
            already_processed.append('Identnummer')
            showIndent(outfile, level)
            outfile.write('Identnummer = "%s",\n' % (self.Identnummer,))
        if self.Anzahl is not None and 'Anzahl' not in already_processed:
            already_processed.append('Anzahl')
            showIndent(outfile, level)
            outfile.write('Anzahl = "%s",\n' % (self.Anzahl,))
        if self.Oberflaeche is not None and 'Oberflaeche' not in already_processed:
            already_processed.append('Oberflaeche')
            showIndent(outfile, level)
            outfile.write('Oberflaeche = "%s",\n' % (self.Oberflaeche,))
        if self.Bezeichnung is not None and 'Bezeichnung' not in already_processed:
            already_processed.append('Bezeichnung')
            showIndent(outfile, level)
            outfile.write('Bezeichnung = "%s",\n' % (self.Bezeichnung,))
        if self.WinkelY is not None and 'WinkelY' not in already_processed:
            already_processed.append('WinkelY')
            showIndent(outfile, level)
            outfile.write('WinkelY = "%s",\n' % (self.WinkelY,))
        if self.WinkelX is not None and 'WinkelX' not in already_processed:
            already_processed.append('WinkelX')
            showIndent(outfile, level)
            outfile.write('WinkelX = "%s",\n' % (self.WinkelX,))
        if self.WinkelZ is not None and 'WinkelZ' not in already_processed:
            already_processed.append('WinkelZ')
            showIndent(outfile, level)
            outfile.write('WinkelZ = "%s",\n' % (self.WinkelZ,))
        if self.Artikelnummer is not None and 'Artikelnummer' not in already_processed:
            already_processed.append('Artikelnummer')
            showIndent(outfile, level)
            outfile.write('Artikelnummer = "%s",\n' % (self.Artikelnummer,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Artikel=[\n')
        level += 1
        for Artikel_ in self.Artikel:
            showIndent(outfile, level)
            outfile.write('model_.ArtikelType(\n')
            Artikel_.exportLiteral(outfile, level, name_='ArtikelType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Ablaengen is not None:
            showIndent(outfile, level)
            outfile.write('Ablaengen=model_.AblaengenType(\n')
            self.Ablaengen.exportLiteral(outfile, level, name_='Ablaengen')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Skalierung is not None:
            showIndent(outfile, level)
            outfile.write('Skalierung=model_.VectorType(\n')
            self.Skalierung.exportLiteral(outfile, level, name_='Skalierung')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('PositionZ', node)
        if value is not None and 'PositionZ' not in already_processed:
            already_processed.append('PositionZ')
            self.PositionZ = value
        value = find_attr_value_('PositionX', node)
        if value is not None and 'PositionX' not in already_processed:
            already_processed.append('PositionX')
            self.PositionX = value
        value = find_attr_value_('PositionY', node)
        if value is not None and 'PositionY' not in already_processed:
            already_processed.append('PositionY')
            self.PositionY = value
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        value = find_attr_value_('Bezug', node)
        if value is not None and 'Bezug' not in already_processed:
            already_processed.append('Bezug')
            self.Bezug = value
        value = find_attr_value_('Identnummer', node)
        if value is not None and 'Identnummer' not in already_processed:
            already_processed.append('Identnummer')
            self.Identnummer = value
        value = find_attr_value_('Anzahl', node)
        if value is not None and 'Anzahl' not in already_processed:
            already_processed.append('Anzahl')
            self.Anzahl = value
        value = find_attr_value_('Oberflaeche', node)
        if value is not None and 'Oberflaeche' not in already_processed:
            already_processed.append('Oberflaeche')
            self.Oberflaeche = value
        value = find_attr_value_('Bezeichnung', node)
        if value is not None and 'Bezeichnung' not in already_processed:
            already_processed.append('Bezeichnung')
            self.Bezeichnung = value
        value = find_attr_value_('WinkelY', node)
        if value is not None and 'WinkelY' not in already_processed:
            already_processed.append('WinkelY')
            self.WinkelY = value
        value = find_attr_value_('WinkelX', node)
        if value is not None and 'WinkelX' not in already_processed:
            already_processed.append('WinkelX')
            self.WinkelX = value
        value = find_attr_value_('WinkelZ', node)
        if value is not None and 'WinkelZ' not in already_processed:
            already_processed.append('WinkelZ')
            self.WinkelZ = value
        value = find_attr_value_('Artikelnummer', node)
        if value is not None and 'Artikelnummer' not in already_processed:
            already_processed.append('Artikelnummer')
            self.Artikelnummer = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Artikel':
            obj_ = ArtikelType.factory()
            obj_.build(child_)
            self.Artikel.append(obj_)
        elif nodeName_ == 'Ablaengen':
            obj_ = AblaengenType.factory()
            obj_.build(child_)
            self.set_Ablaengen(obj_)
        elif nodeName_ == 'Skalierung':
            class_obj_ = self.get_class_obj_(child_, VectorType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_Skalierung(obj_)
# end class ArtikelType


class AblaengenType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ReferenzX=None, ReferenzY=None, ReferenzZ=None, LaengeZ=None, LaengeY=None, LaengeX=None):
        self.ReferenzX = _cast(float, ReferenzX)
        self.ReferenzY = _cast(float, ReferenzY)
        self.ReferenzZ = _cast(float, ReferenzZ)
        self.LaengeZ = _cast(float, LaengeZ)
        self.LaengeY = _cast(float, LaengeY)
        self.LaengeX = _cast(float, LaengeX)
        pass
    def factory(*args_, **kwargs_):
        if AblaengenType.subclass:
            return AblaengenType.subclass(*args_, **kwargs_)
        else:
            return AblaengenType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ReferenzX(self): return self.ReferenzX
    def set_ReferenzX(self, ReferenzX): self.ReferenzX = ReferenzX
    def get_ReferenzY(self): return self.ReferenzY
    def set_ReferenzY(self, ReferenzY): self.ReferenzY = ReferenzY
    def get_ReferenzZ(self): return self.ReferenzZ
    def set_ReferenzZ(self, ReferenzZ): self.ReferenzZ = ReferenzZ
    def get_LaengeZ(self): return self.LaengeZ
    def set_LaengeZ(self, LaengeZ): self.LaengeZ = LaengeZ
    def get_LaengeY(self): return self.LaengeY
    def set_LaengeY(self, LaengeY): self.LaengeY = LaengeY
    def get_LaengeX(self): return self.LaengeX
    def set_LaengeX(self, LaengeX): self.LaengeX = LaengeX
    def export(self, outfile, level, namespace_='', name_='AblaengenType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AblaengenType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AblaengenType'):
        if self.ReferenzX is not None and 'ReferenzX' not in already_processed:
            already_processed.append('ReferenzX')
            outfile.write(' ReferenzX="%s"' % self.gds_format_float(self.ReferenzX, input_name='ReferenzX'))
        if self.ReferenzY is not None and 'ReferenzY' not in already_processed:
            already_processed.append('ReferenzY')
            outfile.write(' ReferenzY="%s"' % self.gds_format_float(self.ReferenzY, input_name='ReferenzY'))
        if self.ReferenzZ is not None and 'ReferenzZ' not in already_processed:
            already_processed.append('ReferenzZ')
            outfile.write(' ReferenzZ="%s"' % self.gds_format_float(self.ReferenzZ, input_name='ReferenzZ'))
        if self.LaengeZ is not None and 'LaengeZ' not in already_processed:
            already_processed.append('LaengeZ')
            outfile.write(' LaengeZ="%s"' % self.gds_format_float(self.LaengeZ, input_name='LaengeZ'))
        if self.LaengeY is not None and 'LaengeY' not in already_processed:
            already_processed.append('LaengeY')
            outfile.write(' LaengeY="%s"' % self.gds_format_float(self.LaengeY, input_name='LaengeY'))
        if self.LaengeX is not None and 'LaengeX' not in already_processed:
            already_processed.append('LaengeX')
            outfile.write(' LaengeX="%s"' % self.gds_format_float(self.LaengeX, input_name='LaengeX'))
    def exportChildren(self, outfile, level, namespace_='', name_='AblaengenType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AblaengenType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ReferenzX is not None and 'ReferenzX' not in already_processed:
            already_processed.append('ReferenzX')
            showIndent(outfile, level)
            outfile.write('ReferenzX = %e,\n' % (self.ReferenzX,))
        if self.ReferenzY is not None and 'ReferenzY' not in already_processed:
            already_processed.append('ReferenzY')
            showIndent(outfile, level)
            outfile.write('ReferenzY = %e,\n' % (self.ReferenzY,))
        if self.ReferenzZ is not None and 'ReferenzZ' not in already_processed:
            already_processed.append('ReferenzZ')
            showIndent(outfile, level)
            outfile.write('ReferenzZ = %e,\n' % (self.ReferenzZ,))
        if self.LaengeZ is not None and 'LaengeZ' not in already_processed:
            already_processed.append('LaengeZ')
            showIndent(outfile, level)
            outfile.write('LaengeZ = %e,\n' % (self.LaengeZ,))
        if self.LaengeY is not None and 'LaengeY' not in already_processed:
            already_processed.append('LaengeY')
            showIndent(outfile, level)
            outfile.write('LaengeY = %e,\n' % (self.LaengeY,))
        if self.LaengeX is not None and 'LaengeX' not in already_processed:
            already_processed.append('LaengeX')
            showIndent(outfile, level)
            outfile.write('LaengeX = %e,\n' % (self.LaengeX,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ReferenzX', node)
        if value is not None and 'ReferenzX' not in already_processed:
            already_processed.append('ReferenzX')
            try:
                self.ReferenzX = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (ReferenzX): %s' % exp)
        value = find_attr_value_('ReferenzY', node)
        if value is not None and 'ReferenzY' not in already_processed:
            already_processed.append('ReferenzY')
            try:
                self.ReferenzY = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (ReferenzY): %s' % exp)
        value = find_attr_value_('ReferenzZ', node)
        if value is not None and 'ReferenzZ' not in already_processed:
            already_processed.append('ReferenzZ')
            try:
                self.ReferenzZ = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (ReferenzZ): %s' % exp)
        value = find_attr_value_('LaengeZ', node)
        if value is not None and 'LaengeZ' not in already_processed:
            already_processed.append('LaengeZ')
            try:
                self.LaengeZ = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (LaengeZ): %s' % exp)
        value = find_attr_value_('LaengeY', node)
        if value is not None and 'LaengeY' not in already_processed:
            already_processed.append('LaengeY')
            try:
                self.LaengeY = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (LaengeY): %s' % exp)
        value = find_attr_value_('LaengeX', node)
        if value is not None and 'LaengeX' not in already_processed:
            already_processed.append('LaengeX')
            try:
                self.LaengeX = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (LaengeX): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AblaengenType


class LayerZuordnungType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Von=None, Nach=None):
        self.Von = _cast(None, Von)
        self.Nach = _cast(None, Nach)
        pass
    def factory(*args_, **kwargs_):
        if LayerZuordnungType.subclass:
            return LayerZuordnungType.subclass(*args_, **kwargs_)
        else:
            return LayerZuordnungType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Von(self): return self.Von
    def set_Von(self, Von): self.Von = Von
    def get_Nach(self): return self.Nach
    def set_Nach(self, Nach): self.Nach = Nach
    def export(self, outfile, level, namespace_='', name_='LayerZuordnungType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LayerZuordnungType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LayerZuordnungType'):
        if self.Von is not None and 'Von' not in already_processed:
            already_processed.append('Von')
            outfile.write(' Von=%s' % (self.gds_format_string(quote_attrib(self.Von), input_name='Von'), ))
        if self.Nach is not None and 'Nach' not in already_processed:
            already_processed.append('Nach')
            outfile.write(' Nach=%s' % (self.gds_format_string(quote_attrib(self.Nach), input_name='Nach'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LayerZuordnungType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LayerZuordnungType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Von is not None and 'Von' not in already_processed:
            already_processed.append('Von')
            showIndent(outfile, level)
            outfile.write('Von = "%s",\n' % (self.Von,))
        if self.Nach is not None and 'Nach' not in already_processed:
            already_processed.append('Nach')
            showIndent(outfile, level)
            outfile.write('Nach = "%s",\n' % (self.Nach,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Von', node)
        if value is not None and 'Von' not in already_processed:
            already_processed.append('Von')
            self.Von = value
        value = find_attr_value_('Nach', node)
        if value is not None and 'Nach' not in already_processed:
            already_processed.append('Nach')
            self.Nach = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LayerZuordnungType


class VerrundungType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Kante=None, Radius=None):
        self.Kante = _cast(None, Kante)
        self.Radius = _cast(None, Radius)
        pass
    def factory(*args_, **kwargs_):
        if VerrundungType.subclass:
            return VerrundungType.subclass(*args_, **kwargs_)
        else:
            return VerrundungType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Kante(self): return self.Kante
    def set_Kante(self, Kante): self.Kante = Kante
    def get_Radius(self): return self.Radius
    def set_Radius(self, Radius): self.Radius = Radius
    def export(self, outfile, level, namespace_='', name_='VerrundungType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VerrundungType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VerrundungType'):
        if self.Kante is not None and 'Kante' not in already_processed:
            already_processed.append('Kante')
            outfile.write(' Kante=%s' % (self.gds_format_string(quote_attrib(self.Kante), input_name='Kante'), ))
        if self.Radius is not None and 'Radius' not in already_processed:
            already_processed.append('Radius')
            outfile.write(' Radius=%s' % (self.gds_format_string(quote_attrib(self.Radius), input_name='Radius'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='VerrundungType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VerrundungType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Kante is not None and 'Kante' not in already_processed:
            already_processed.append('Kante')
            showIndent(outfile, level)
            outfile.write('Kante = "%s",\n' % (self.Kante,))
        if self.Radius is not None and 'Radius' not in already_processed:
            already_processed.append('Radius')
            showIndent(outfile, level)
            outfile.write('Radius = "%s",\n' % (self.Radius,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Kante', node)
        if value is not None and 'Kante' not in already_processed:
            already_processed.append('Kante')
            self.Kante = value
        value = find_attr_value_('Radius', node)
        if value is not None and 'Radius' not in already_processed:
            already_processed.append('Radius')
            self.Radius = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VerrundungType


class AttributType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Wert=None, MIN=None, MAX=None, Front=None, Griff=None, Sperren=None, Typ=None, valueOf_=None):
        self.Name = _cast(None, Name)
        self.Wert = _cast(None, Wert)
        self.MIN = _cast(None, MIN)
        self.MAX = _cast(None, MAX)
        self.Front = _cast(None, Front)
        self.Griff = _cast(None, Griff)
        self.Sperren = _cast(None, Sperren)
        self.Typ = _cast(None, Typ)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AttributType.subclass:
            return AttributType.subclass(*args_, **kwargs_)
        else:
            return AttributType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Wert(self): return self.Wert
    def set_Wert(self, Wert): self.Wert = Wert
    def get_MIN(self): return self.MIN
    def set_MIN(self, MIN): self.MIN = MIN
    def get_MAX(self): return self.MAX
    def set_MAX(self, MAX): self.MAX = MAX
    def get_Front(self): return self.Front
    def set_Front(self, Front): self.Front = Front
    def get_Griff(self): return self.Griff
    def set_Griff(self, Griff): self.Griff = Griff
    def get_Sperren(self): return self.Sperren
    def set_Sperren(self, Sperren): self.Sperren = Sperren
    def get_Typ(self): return self.Typ
    def set_Typ(self, Typ): self.Typ = Typ
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='AttributType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttributType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AttributType'):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name), input_name='Name'), ))
        if self.Wert is not None and 'Wert' not in already_processed:
            already_processed.append('Wert')
            outfile.write(' Wert=%s' % (self.gds_format_string(quote_attrib(self.Wert), input_name='Wert'), ))
        if self.MIN is not None and 'MIN' not in already_processed:
            already_processed.append('MIN')
            outfile.write(' MIN=%s' % (self.gds_format_string(quote_attrib(self.MIN), input_name='MIN'), ))
        if self.MAX is not None and 'MAX' not in already_processed:
            already_processed.append('MAX')
            outfile.write(' MAX=%s' % (self.gds_format_string(quote_attrib(self.MAX), input_name='MAX'), ))
        if self.Front is not None and 'Front' not in already_processed:
            already_processed.append('Front')
            outfile.write(' Front=%s' % (self.gds_format_string(quote_attrib(self.Front), input_name='Front'), ))
        if self.Griff is not None and 'Griff' not in already_processed:
            already_processed.append('Griff')
            outfile.write(' Griff=%s' % (self.gds_format_string(quote_attrib(self.Griff), input_name='Griff'), ))
        if self.Sperren is not None and 'Sperren' not in already_processed:
            already_processed.append('Sperren')
            outfile.write(' Sperren=%s' % (self.gds_format_string(quote_attrib(self.Sperren), input_name='Sperren'), ))
        if self.Typ is not None and 'Typ' not in already_processed:
            already_processed.append('Typ')
            outfile.write(' Typ=%s' % (self.gds_format_string(quote_attrib(self.Typ), input_name='Typ'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AttributType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AttributType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        if self.Wert is not None and 'Wert' not in already_processed:
            already_processed.append('Wert')
            showIndent(outfile, level)
            outfile.write('Wert = "%s",\n' % (self.Wert,))
        if self.MIN is not None and 'MIN' not in already_processed:
            already_processed.append('MIN')
            showIndent(outfile, level)
            outfile.write('MIN = "%s",\n' % (self.MIN,))
        if self.MAX is not None and 'MAX' not in already_processed:
            already_processed.append('MAX')
            showIndent(outfile, level)
            outfile.write('MAX = "%s",\n' % (self.MAX,))
        if self.Front is not None and 'Front' not in already_processed:
            already_processed.append('Front')
            showIndent(outfile, level)
            outfile.write('Front = "%s",\n' % (self.Front,))
        if self.Griff is not None and 'Griff' not in already_processed:
            already_processed.append('Griff')
            showIndent(outfile, level)
            outfile.write('Griff = "%s",\n' % (self.Griff,))
        if self.Sperren is not None and 'Sperren' not in already_processed:
            already_processed.append('Sperren')
            showIndent(outfile, level)
            outfile.write('Sperren = "%s",\n' % (self.Sperren,))
        if self.Typ is not None and 'Typ' not in already_processed:
            already_processed.append('Typ')
            showIndent(outfile, level)
            outfile.write('Typ = "%s",\n' % (self.Typ,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        value = find_attr_value_('Wert', node)
        if value is not None and 'Wert' not in already_processed:
            already_processed.append('Wert')
            self.Wert = value
        value = find_attr_value_('MIN', node)
        if value is not None and 'MIN' not in already_processed:
            already_processed.append('MIN')
            self.MIN = value
        value = find_attr_value_('MAX', node)
        if value is not None and 'MAX' not in already_processed:
            already_processed.append('MAX')
            self.MAX = value
        value = find_attr_value_('Front', node)
        if value is not None and 'Front' not in already_processed:
            already_processed.append('Front')
            self.Front = value
        value = find_attr_value_('Griff', node)
        if value is not None and 'Griff' not in already_processed:
            already_processed.append('Griff')
            self.Griff = value
        value = find_attr_value_('Sperren', node)
        if value is not None and 'Sperren' not in already_processed:
            already_processed.append('Sperren')
            self.Sperren = value
        value = find_attr_value_('Typ', node)
        if value is not None and 'Typ' not in already_processed:
            already_processed.append('Typ')
            self.Typ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AttributType


class GeometryType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, ID=None, Quader=None, Polygon=None, Bohrbild=None, extensiontype_=None):
        self.Name = _cast(None, Name)
        self.ID = _cast(None, ID)
        self.Quader = Quader
        self.Polygon = Polygon
        if Bohrbild is None:
            self.Bohrbild = []
        else:
            self.Bohrbild = Bohrbild
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if GeometryType.subclass:
            return GeometryType.subclass(*args_, **kwargs_)
        else:
            return GeometryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Quader(self): return self.Quader
    def set_Quader(self, Quader): self.Quader = Quader
    def get_Polygon(self): return self.Polygon
    def set_Polygon(self, Polygon): self.Polygon = Polygon
    def get_Bohrbild(self): return self.Bohrbild
    def set_Bohrbild(self, Bohrbild): self.Bohrbild = Bohrbild
    def add_Bohrbild(self, value): self.Bohrbild.append(value)
    def insert_Bohrbild(self, index, value): self.Bohrbild[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='GeometryType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeometryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GeometryType'):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name), input_name='Name'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID), input_name='ID'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='GeometryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Quader is not None:
            self.Quader.export(outfile, level, namespace_, name_='Quader', pretty_print=pretty_print)
        if self.Polygon is not None:
            self.Polygon.export(outfile, level, namespace_, name_='Polygon', pretty_print=pretty_print)
        for Bohrbild_ in self.Bohrbild:
            Bohrbild_.export(outfile, level, namespace_, name_='Bohrbild', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Quader is not None or
            self.Polygon is not None or
            self.Bohrbild
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GeometryType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Quader is not None:
            showIndent(outfile, level)
            outfile.write('Quader=model_.QuaderType(\n')
            self.Quader.exportLiteral(outfile, level, name_='Quader')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Polygon is not None:
            showIndent(outfile, level)
            outfile.write('Polygon=model_.PolygonType(\n')
            self.Polygon.exportLiteral(outfile, level, name_='Polygon')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Bohrbild=[\n')
        level += 1
        for Bohrbild_ in self.Bohrbild:
            showIndent(outfile, level)
            outfile.write('model_.BohrbildType(\n')
            Bohrbild_.exportLiteral(outfile, level, name_='BohrbildType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Quader':
            obj_ = QuaderType.factory()
            obj_.build(child_)
            self.set_Quader(obj_)
        elif nodeName_ == 'Polygon':
            obj_ = PolygonType.factory()
            obj_.build(child_)
            self.set_Polygon(obj_)
        elif nodeName_ == 'Bohrbild':
            obj_ = BohrbildType.factory()
            obj_.build(child_)
            self.Bohrbild.append(obj_)
# end class GeometryType


class LinienType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, L=None):
        if L is None:
            self.L = []
        else:
            self.L = L
    def factory(*args_, **kwargs_):
        if LinienType.subclass:
            return LinienType.subclass(*args_, **kwargs_)
        else:
            return LinienType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_L(self): return self.L
    def set_L(self, L): self.L = L
    def add_L(self, value): self.L.append(value)
    def insert_L(self, index, value): self.L[index] = value
    def export(self, outfile, level, namespace_='', name_='LinienType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinienType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LinienType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LinienType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for L_ in self.L:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sL>%s</%sL>%s' % (namespace_, self.gds_format_string(quote_xml(L_), input_name='L'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.L
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LinienType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('L=[\n')
        level += 1
        for L_ in self.L:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(L_))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'L':
            L_ = child_.text
            L_ = self.gds_validate_string(L_, node, 'L')
            self.L.append(L_)
# end class LinienType


class ViewType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, L=None, Dim=None):
        if L is None:
            self.L = []
        else:
            self.L = L
        if Dim is None:
            self.Dim = []
        else:
            self.Dim = Dim
    def factory(*args_, **kwargs_):
        if ViewType.subclass:
            return ViewType.subclass(*args_, **kwargs_)
        else:
            return ViewType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_L(self): return self.L
    def set_L(self, L): self.L = L
    def add_L(self, value): self.L.append(value)
    def insert_L(self, index, value): self.L[index] = value
    def get_Dim(self): return self.Dim
    def set_Dim(self, Dim): self.Dim = Dim
    def add_Dim(self, value): self.Dim.append(value)
    def insert_Dim(self, index, value): self.Dim[index] = value
    def export(self, outfile, level, namespace_='', name_='ViewType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ViewType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ViewType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ViewType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for L_ in self.L:
            L_.export(outfile, level, namespace_, name_='L', pretty_print=pretty_print)
        for Dim_ in self.Dim:
            Dim_.export(outfile, level, namespace_, name_='Dim', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.L or
            self.Dim
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ViewType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('L=[\n')
        level += 1
        for L_ in self.L:
            showIndent(outfile, level)
            outfile.write('model_.LineType(\n')
            L_.exportLiteral(outfile, level, name_='LineType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Dim=[\n')
        level += 1
        for Dim_ in self.Dim:
            showIndent(outfile, level)
            outfile.write('model_.DimType(\n')
            Dim_.exportLiteral(outfile, level, name_='DimType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'L':
            obj_ = LineType.factory()
            obj_.build(child_)
            self.L.append(obj_)
        elif nodeName_ == 'Dim':
            obj_ = DimType.factory()
            obj_.build(child_)
            self.Dim.append(obj_)
# end class ViewType


class PunkteType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Bezug=None, p=None):
        self.Bezug = _cast(None, Bezug)
        if p is None:
            self.p = []
        else:
            self.p = p
    def factory(*args_, **kwargs_):
        if PunkteType.subclass:
            return PunkteType.subclass(*args_, **kwargs_)
        else:
            return PunkteType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_p(self): return self.p
    def set_p(self, p): self.p = p
    def add_p(self, value): self.p.append(value)
    def insert_p(self, index, value): self.p[index] = value
    def get_Bezug(self): return self.Bezug
    def set_Bezug(self, Bezug): self.Bezug = Bezug
    def export(self, outfile, level, namespace_='', name_='PunkteType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PunkteType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PunkteType'):
        if self.Bezug is not None and 'Bezug' not in already_processed:
            already_processed.append('Bezug')
            outfile.write(' Bezug=%s' % (self.gds_format_string(quote_attrib(self.Bezug), input_name='Bezug'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PunkteType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for p_ in self.p:
            p_.export(outfile, level, namespace_, name_='p', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.p
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PunkteType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Bezug is not None and 'Bezug' not in already_processed:
            already_processed.append('Bezug')
            showIndent(outfile, level)
            outfile.write('Bezug = "%s",\n' % (self.Bezug,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('p=[\n')
        level += 1
        for p_ in self.p:
            showIndent(outfile, level)
            outfile.write('model_.pType(\n')
            p_.exportLiteral(outfile, level, name_='pType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Bezug', node)
        if value is not None and 'Bezug' not in already_processed:
            already_processed.append('Bezug')
            self.Bezug = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'p':
            obj_ = pType.factory()
            obj_.build(child_)
            self.p.append(obj_)
# end class PunkteType


class FasenType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Fase=None):
        if Fase is None:
            self.Fase = []
        else:
            self.Fase = Fase
    def factory(*args_, **kwargs_):
        if FasenType.subclass:
            return FasenType.subclass(*args_, **kwargs_)
        else:
            return FasenType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Fase(self): return self.Fase
    def set_Fase(self, Fase): self.Fase = Fase
    def add_Fase(self, value): self.Fase.append(value)
    def insert_Fase(self, index, value): self.Fase[index] = value
    def export(self, outfile, level, namespace_='', name_='FasenType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FasenType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FasenType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FasenType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Fase_ in self.Fase:
            Fase_.export(outfile, level, namespace_, name_='Fase', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Fase
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FasenType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Fase=[\n')
        level += 1
        for Fase_ in self.Fase:
            showIndent(outfile, level)
            outfile.write('model_.FaseType(\n')
            Fase_.exportLiteral(outfile, level, name_='FaseType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Fase':
            obj_ = FaseType.factory()
            obj_.build(child_)
            self.Fase.append(obj_)
# end class FasenType


class DimType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, typ=None, o=None, v=None, valueOf_=None):
        self.typ = _cast(None, typ)
        self.o = _cast(None, o)
        self.v = _cast(None, v)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DimType.subclass:
            return DimType.subclass(*args_, **kwargs_)
        else:
            return DimType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_typ(self): return self.typ
    def set_typ(self, typ): self.typ = typ
    def get_o(self): return self.o
    def set_o(self, o): self.o = o
    def get_v(self): return self.v
    def set_v(self, v): self.v = v
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='DimType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DimType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DimType'):
        if self.typ is not None and 'typ' not in already_processed:
            already_processed.append('typ')
            outfile.write(' typ=%s' % (self.gds_format_string(quote_attrib(self.typ), input_name='typ'), ))
        if self.o is not None and 'o' not in already_processed:
            already_processed.append('o')
            outfile.write(' o=%s' % (self.gds_format_string(quote_attrib(self.o), input_name='o'), ))
        if self.v is not None and 'v' not in already_processed:
            already_processed.append('v')
            outfile.write(' v=%s' % (self.gds_format_string(quote_attrib(self.v), input_name='v'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DimType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DimType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.typ is not None and 'typ' not in already_processed:
            already_processed.append('typ')
            showIndent(outfile, level)
            outfile.write('typ = "%s",\n' % (self.typ,))
        if self.o is not None and 'o' not in already_processed:
            already_processed.append('o')
            showIndent(outfile, level)
            outfile.write('o = "%s",\n' % (self.o,))
        if self.v is not None and 'v' not in already_processed:
            already_processed.append('v')
            showIndent(outfile, level)
            outfile.write('v = "%s",\n' % (self.v,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('typ', node)
        if value is not None and 'typ' not in already_processed:
            already_processed.append('typ')
            self.typ = value
        value = find_attr_value_('o', node)
        if value is not None and 'o' not in already_processed:
            already_processed.append('o')
            self.o = value
        value = find_attr_value_('v', node)
        if value is not None and 'v' not in already_processed:
            already_processed.append('v')
            self.v = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DimType


class LineType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, v=None, valueOf_=None):
        self.v = _cast(None, v)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if LineType.subclass:
            return LineType.subclass(*args_, **kwargs_)
        else:
            return LineType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_v(self): return self.v
    def set_v(self, v): self.v = v
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='LineType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LineType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LineType'):
        if self.v is not None and 'v' not in already_processed:
            already_processed.append('v')
            outfile.write(' v=%s' % (self.gds_format_string(quote_attrib(self.v), input_name='v'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LineType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LineType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.v is not None and 'v' not in already_processed:
            already_processed.append('v')
            showIndent(outfile, level)
            outfile.write('v = "%s",\n' % (self.v,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('v', node)
        if value is not None and 'v' not in already_processed:
            already_processed.append('v')
            self.v = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LineType


class FaseType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Abstand=None, Kante=None, Winkel=None):
        self.Abstand = _cast(None, Abstand)
        self.Kante = _cast(None, Kante)
        self.Winkel = _cast(None, Winkel)
        pass
    def factory(*args_, **kwargs_):
        if FaseType.subclass:
            return FaseType.subclass(*args_, **kwargs_)
        else:
            return FaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Abstand(self): return self.Abstand
    def set_Abstand(self, Abstand): self.Abstand = Abstand
    def get_Kante(self): return self.Kante
    def set_Kante(self, Kante): self.Kante = Kante
    def get_Winkel(self): return self.Winkel
    def set_Winkel(self, Winkel): self.Winkel = Winkel
    def export(self, outfile, level, namespace_='', name_='FaseType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FaseType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FaseType'):
        if self.Abstand is not None and 'Abstand' not in already_processed:
            already_processed.append('Abstand')
            outfile.write(' Abstand=%s' % (self.gds_format_string(quote_attrib(self.Abstand), input_name='Abstand'), ))
        if self.Kante is not None and 'Kante' not in already_processed:
            already_processed.append('Kante')
            outfile.write(' Kante=%s' % (self.gds_format_string(quote_attrib(self.Kante), input_name='Kante'), ))
        if self.Winkel is not None and 'Winkel' not in already_processed:
            already_processed.append('Winkel')
            outfile.write(' Winkel=%s' % (self.gds_format_string(quote_attrib(self.Winkel), input_name='Winkel'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FaseType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FaseType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Abstand is not None and 'Abstand' not in already_processed:
            already_processed.append('Abstand')
            showIndent(outfile, level)
            outfile.write('Abstand = "%s",\n' % (self.Abstand,))
        if self.Kante is not None and 'Kante' not in already_processed:
            already_processed.append('Kante')
            showIndent(outfile, level)
            outfile.write('Kante = "%s",\n' % (self.Kante,))
        if self.Winkel is not None and 'Winkel' not in already_processed:
            already_processed.append('Winkel')
            showIndent(outfile, level)
            outfile.write('Winkel = "%s",\n' % (self.Winkel,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Abstand', node)
        if value is not None and 'Abstand' not in already_processed:
            already_processed.append('Abstand')
            self.Abstand = value
        value = find_attr_value_('Kante', node)
        if value is not None and 'Kante' not in already_processed:
            already_processed.append('Kante')
            self.Kante = value
        value = find_attr_value_('Winkel', node)
        if value is not None and 'Winkel' not in already_processed:
            already_processed.append('Winkel')
            self.Winkel = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FaseType


class ZylinderType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, von_Bohrbild=None, Position=None, Orientierung=None, Hoehe=None, Radius=None):
        self.von_Bohrbild = _cast(None, von_Bohrbild)
        self.Position = Position
        self.Orientierung = Orientierung
        self.Hoehe = Hoehe
        self.Radius = Radius
    def factory(*args_, **kwargs_):
        if ZylinderType.subclass:
            return ZylinderType.subclass(*args_, **kwargs_)
        else:
            return ZylinderType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Position(self): return self.Position
    def set_Position(self, Position): self.Position = Position
    def get_Orientierung(self): return self.Orientierung
    def set_Orientierung(self, Orientierung): self.Orientierung = Orientierung
    def get_Hoehe(self): return self.Hoehe
    def set_Hoehe(self, Hoehe): self.Hoehe = Hoehe
    def get_Radius(self): return self.Radius
    def set_Radius(self, Radius): self.Radius = Radius
    def get_von_Bohrbild(self): return self.von_Bohrbild
    def set_von_Bohrbild(self, von_Bohrbild): self.von_Bohrbild = von_Bohrbild
    def export(self, outfile, level, namespace_='', name_='ZylinderType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ZylinderType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ZylinderType'):
        if self.von_Bohrbild is not None and 'von_Bohrbild' not in already_processed:
            already_processed.append('von_Bohrbild')
            outfile.write(' von_Bohrbild=%s' % (self.gds_format_string(quote_attrib(self.von_Bohrbild), input_name='von_Bohrbild'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ZylinderType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Position is not None:
            self.Position.export(outfile, level, namespace_, name_='Position', pretty_print=pretty_print)
        if self.Orientierung is not None:
            self.Orientierung.export(outfile, level, namespace_, name_='Orientierung', pretty_print=pretty_print)
        if self.Hoehe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHoehe>%s</%sHoehe>%s' % (namespace_, self.gds_format_float(self.Hoehe, input_name='Hoehe'), namespace_, eol_))
        if self.Radius is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRadius>%s</%sRadius>%s' % (namespace_, self.gds_format_float(self.Radius, input_name='Radius'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.Position is not None or
            self.Orientierung is not None or
            self.Hoehe is not None or
            self.Radius is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ZylinderType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.von_Bohrbild is not None and 'von_Bohrbild' not in already_processed:
            already_processed.append('von_Bohrbild')
            showIndent(outfile, level)
            outfile.write('von_Bohrbild = "%s",\n' % (self.von_Bohrbild,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Position is not None:
            showIndent(outfile, level)
            outfile.write('Position=model_.PunktType(\n')
            self.Position.exportLiteral(outfile, level, name_='Position')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Orientierung is not None:
            showIndent(outfile, level)
            outfile.write('Orientierung=model_.PunktType(\n')
            self.Orientierung.exportLiteral(outfile, level, name_='Orientierung')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Hoehe is not None:
            showIndent(outfile, level)
            outfile.write('Hoehe=%e,\n' % self.Hoehe)
        if self.Radius is not None:
            showIndent(outfile, level)
            outfile.write('Radius=%e,\n' % self.Radius)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('von_Bohrbild', node)
        if value is not None and 'von_Bohrbild' not in already_processed:
            already_processed.append('von_Bohrbild')
            self.von_Bohrbild = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Position':
            obj_ = PunktType.factory()
            obj_.build(child_)
            self.set_Position(obj_)
        elif nodeName_ == 'Orientierung':
            obj_ = PunktType.factory()
            obj_.build(child_)
            self.set_Orientierung(obj_)
        elif nodeName_ == 'Hoehe':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Hoehe')
            self.Hoehe = fval_
        elif nodeName_ == 'Radius':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Radius')
            self.Radius = fval_
# end class ZylinderType


class VectorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Y=None, X=None, Z=None, extensiontype_=None):
        self.Y = _cast(float, Y)
        self.X = _cast(float, X)
        self.Z = _cast(float, Z)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if VectorType.subclass:
            return VectorType.subclass(*args_, **kwargs_)
        else:
            return VectorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Y(self): return self.Y
    def set_Y(self, Y): self.Y = Y
    def get_X(self): return self.X
    def set_X(self, X): self.X = X
    def get_Z(self): return self.Z
    def set_Z(self, Z): self.Z = Z
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='VectorType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VectorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VectorType'):
        if self.Y is not None and 'Y' not in already_processed:
            already_processed.append('Y')
            outfile.write(' Y="%s"' % self.gds_format_float(self.Y, input_name='Y'))
        if self.X is not None and 'X' not in already_processed:
            already_processed.append('X')
            outfile.write(' X="%s"' % self.gds_format_float(self.X, input_name='X'))
        if self.Z is not None and 'Z' not in already_processed:
            already_processed.append('Z')
            outfile.write(' Z="%s"' % self.gds_format_float(self.Z, input_name='Z'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='VectorType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VectorType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Y is not None and 'Y' not in already_processed:
            already_processed.append('Y')
            showIndent(outfile, level)
            outfile.write('Y = %e,\n' % (self.Y,))
        if self.X is not None and 'X' not in already_processed:
            already_processed.append('X')
            showIndent(outfile, level)
            outfile.write('X = %e,\n' % (self.X,))
        if self.Z is not None and 'Z' not in already_processed:
            already_processed.append('Z')
            showIndent(outfile, level)
            outfile.write('Z = %e,\n' % (self.Z,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Y', node)
        if value is not None and 'Y' not in already_processed:
            already_processed.append('Y')
            try:
                self.Y = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Y): %s' % exp)
        value = find_attr_value_('X', node)
        if value is not None and 'X' not in already_processed:
            already_processed.append('X')
            try:
                self.X = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (X): %s' % exp)
        value = find_attr_value_('Z', node)
        if value is not None and 'Z' not in already_processed:
            already_processed.append('Z')
            try:
                self.Z = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Z): %s' % exp)
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VectorType


class DoubleWithId(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, valueOf_=None):
        self.ID = _cast(None, ID)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DoubleWithId.subclass:
            return DoubleWithId.subclass(*args_, **kwargs_)
        else:
            return DoubleWithId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='DoubleWithId', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DoubleWithId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DoubleWithId'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID), input_name='ID'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DoubleWithId', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DoubleWithId'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DoubleWithId


class pType(VectorType):
    subclass = None
    superclass = VectorType
    def __init__(self, Y=None, X=None, Z=None, id=None, idx=None):
        super(pType, self).__init__(Y, X, Z, )
        self.id = _cast(None, id)
        self.idx = _cast(int, idx)
        pass
    def factory(*args_, **kwargs_):
        if pType.subclass:
            return pType.subclass(*args_, **kwargs_)
        else:
            return pType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_idx(self): return self.idx
    def set_idx(self, idx): self.idx = idx
    def export(self, outfile, level, namespace_='', name_='pType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='pType'):
        super(pType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='pType')
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id), input_name='id'), ))
        if self.idx is not None and 'idx' not in already_processed:
            already_processed.append('idx')
            outfile.write(' idx="%s"' % self.gds_format_integer(self.idx, input_name='idx'))
    def exportChildren(self, outfile, level, namespace_='', name_='pType', fromsubclass_=False, pretty_print=True):
        super(pType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def hasContent_(self):
        if (
            super(pType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='pType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
        if self.idx is not None and 'idx' not in already_processed:
            already_processed.append('idx')
            showIndent(outfile, level)
            outfile.write('idx = %d,\n' % (self.idx,))
        super(pType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(pType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('idx', node)
        if value is not None and 'idx' not in already_processed:
            already_processed.append('idx')
            try:
                self.idx = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(pType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(pType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class pType


class PunktType(VectorType):
    subclass = None
    superclass = VectorType
    def __init__(self, Y=None, X=None, Z=None, Bezug=None):
        super(PunktType, self).__init__(Y, X, Z, )
        self.Bezug = _cast(None, Bezug)
        pass
    def factory(*args_, **kwargs_):
        if PunktType.subclass:
            return PunktType.subclass(*args_, **kwargs_)
        else:
            return PunktType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Bezug(self): return self.Bezug
    def set_Bezug(self, Bezug): self.Bezug = Bezug
    def export(self, outfile, level, namespace_='', name_='PunktType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PunktType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PunktType'):
        super(PunktType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PunktType')
        if self.Bezug is not None and 'Bezug' not in already_processed:
            already_processed.append('Bezug')
            outfile.write(' Bezug=%s' % (self.gds_format_string(quote_attrib(self.Bezug), input_name='Bezug'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PunktType', fromsubclass_=False, pretty_print=True):
        super(PunktType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def hasContent_(self):
        if (
            super(PunktType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PunktType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Bezug is not None and 'Bezug' not in already_processed:
            already_processed.append('Bezug')
            showIndent(outfile, level)
            outfile.write('Bezug = "%s",\n' % (self.Bezug,))
        super(PunktType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PunktType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Bezug', node)
        if value is not None and 'Bezug' not in already_processed:
            already_processed.append('Bezug')
            self.Bezug = value
        super(PunktType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PunktType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PunktType


class FrontType(GeometryType):
    subclass = None
    superclass = GeometryType
    def __init__(self, Name=None, ID=None, Quader=None, Polygon=None, Bohrbild=None, Rahmen=None):
        super(FrontType, self).__init__(Name, ID, Quader, Polygon, Bohrbild, )
        self.Rahmen = _cast(None, Rahmen)
        pass
    def factory(*args_, **kwargs_):
        if FrontType.subclass:
            return FrontType.subclass(*args_, **kwargs_)
        else:
            return FrontType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Rahmen(self): return self.Rahmen
    def set_Rahmen(self, Rahmen): self.Rahmen = Rahmen
    def export(self, outfile, level, namespace_='', name_='FrontType', namespacedef_='', pretty_print=True):
        self.DrawTT() # For K3Mebel add
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FrontType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FrontType'):
        super(FrontType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FrontType')
        if self.Rahmen is not None and 'Rahmen' not in already_processed:
            already_processed.append('Rahmen')
            outfile.write(' Rahmen=%s' % (self.gds_format_string(quote_attrib(self.Rahmen), input_name='Rahmen'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FrontType', fromsubclass_=False, pretty_print=True):
        super(FrontType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            super(FrontType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FrontType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Rahmen is not None and 'Rahmen' not in already_processed:
            already_processed.append('Rahmen')
            showIndent(outfile, level)
            outfile.write('Rahmen = "%s",\n' % (self.Rahmen,))
        super(FrontType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FrontType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Rahmen', node)
        if value is not None and 'Rahmen' not in already_processed:
            already_processed.append('Rahmen')
            self.Rahmen = value
        super(FrontType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(FrontType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class FrontType


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Korpus'
        rootClass = Korpus
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n')
    rootObj.export(sys.stdout, 0, name_=rootTag,
        namespacedef_='',
        pretty_print=True)
    return rootObj


def parseString(inString):
    from io import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Korpus'
        rootClass = Korpus
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="Korpus",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Korpus'
        rootClass = Korpus
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from Blum_api7 import *\n\n')
    sys.stdout.write('import Blum_api7 as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
##    args = sys.argv[1:]
##    if len(args) == 1:
##        parse(args[0])
##    else:
##        usage()
    dynalog = mDy.Dynalog()
    gExportPath = dynalog.projectFolder
    listFiles = mDy.getsubs(gExportPath)
    listBXF=mDy.getfilemask(listFiles[1],'*.bxf')
    infilename = mDy.getungfiles(listBXF)

    BXF_path = dynalog.USERPROFILE+'\Documents\Blum\Dynaplan\Kommissionen\Pool\shkafN.bxf'
    infilename = dynalog.USERPROFILE+'\Documents\Blum\Dynaplan\Kommissionen\K3MEBEL\shkaf.bxf'
    global DyKorpus
    DyKorpus = parse(infilename)


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AblaengenType",
    "AnwendungsinformationenType",
    "ArtikelType",
    "AttributType",
    "AttributeListType",
    "AussenschubkastenType",
    "BeschlaegeType",
    "BlindfrontType",
    "BodenType",
    "BohrbildType",
    "BohrradiusType",
    "BohrtiefeType",
    "BohrungenType",
    "DimType",
    "DoppeltuerType",
    "DoubleWithId",
    "FachType",
    "FaseType",
    "FasenType",
    "FrontType",
    "FugendatenType",
    "GeometryType",
    "HeaderType",
    "HolzschubkastenType",
    "InnenFachType",
    "InnenschubkastenType",
    "KlappensystemType",
    "Korpus",
    "KorpusAnbindungType",
    "KorpusdatenType",
    "KorpusdatenValuesType",
    "KorpusinformationenType",
    "LayerZuordnungType",
    "LineType",
    "LinienType",
    "NutFalzType",
    "ParameterlisteType",
    "PlattenType",
    "PlattendickenType",
    "PolygonType",
    "PunktType",
    "PunkteType",
    "QuaderType",
    "RueckwandListType",
    "SERVODRIVEType",
    "SeitenwandType",
    "TraverseType",
    "TuerType",
    "VectorType",
    "VerrundungType",
    "ViewType",
    "VorratsauszugType",
    "ZylinderType",
    "pType"
    ]
